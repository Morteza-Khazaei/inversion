import numpy as np
# from ka import KirchhoffApproximation as KA
from ka import VectorizedKirchhoffApproximation as VKA
from math import factorial
from scipy.special import gamma, kv

class AIEM0:
    def __init__(self, frq_GHz, acf, s, l, eps, thi_deg, ths_deg, phi_deg, phs_deg):
        """
        Initialize AIEM model parameters.

        Parameters:
        - frq_GHz (float): Frequency in GHz
        - acf (str): Autocorrelation function type ('exponential', 'gaussian', etc.)
        - s (float): RMS height (m)
        - l (float): Correlation length (m)
        - eps (complex): Relative complex dielectric constant of the soil
        - thi_deg (float): Incidence angle θi in degrees
        - ths_deg (float): Scattering angle θs in degrees
        - phi_deg (float): Incident azimuth φi in degrees
        - phs_deg (float): Scattering azimuth φs in degrees
        """

        # Constants
        c0 = 299792458  # Speed of light in vacuum (m/s)

        # Frequency and wavenumber
        frq_Hz = frq_GHz * 1e9  # Hz
        wavelength = c0 / frq_Hz  # m
        self.k = 2 * np.pi / wavelength  # Wavenumber (rad/m)

        # Surface properties
        self.acf = acf.lower()
        self.sigma = s  # RMS height
        self.l = l      # Correlation length
        self.ks = self.k * s  # Angular rms height
        self.kl = self.k * l  # Angular correlation length
        self.er = eps  # Complex dielectric constant
        self.ur = 1.0  # Permuablity of air
        # print('ks:', self.ks, 'kl:', self.kl)

        # Angles in degrees
        self.theta_i_deg = thi_deg
        self.theta_s_deg = ths_deg
        self.phi_i_deg = phi_deg
        self.phi_s_deg = phs_deg

        # Convert to radians
        self.theta_i = np.deg2rad(thi_deg)
        self.theta_s = np.deg2rad(ths_deg)
        self.phi_i = np.deg2rad(phi_deg)
        self.phi_s = np.deg2rad(phs_deg)

        # Precompute trigonometric terms
        self.siti = np.sin(self.theta_i)
        self.sits = np.sin(self.theta_s)
        self.csti = np.cos(self.theta_i)
        self.csts = np.cos(self.theta_s)

        self.sifi = np.sin(self.phi_i)
        self.sifs = np.sin(self.phi_s)
        self.csfi = np.cos(self.phi_i)
        self.csfs = np.cos(self.phi_s)

        # Precomputed squared trigonometric terms
        self.csti2 = self.csti ** 2
        self.csts2 = self.csts ** 2
        self.siti2 = self.siti ** 2
        self.sits2 = self.sits ** 2

        # Precomputed squared wave parameters
        self.k2 = self.k**2             # (k)^2
        self.s2 = s**2             # (σ)^2
        self.l2 = self.l**2        # (L)^2
        self.ks2 = self.ks ** 2    # (kσ)^2
        self.kl2 = self.kl ** 2    # (kL)^2

        # Determine radar configuration
        self.is_monostatic = (
            np.isclose(self.theta_i, self.theta_s, atol=1e-6)
            and np.isclose((self.phi_i - self.phi_s) % (2 * np.pi), np.pi, atol=1e-6)
        )

        # if self.is_monostatic:
        #     print("Monostatic configuration detected.")
        # else:
        #     print("Bistatic configuration detected.")

        # Compute wave vector components
        self.kx, self.ky, self.kz = self._spherical_to_cartesian(1, self.theta_i, self.phi_i)
        self.ksx, self.ksy, self.ksz = self._spherical_to_cartesian(1, self.theta_s, self.phi_s)

        # self.zx, self.zy = self.compute_surface_slopes(self.kx, self.ky, -self.kz, self.ksx, self.ksy, self.ksz)

        self.niter = self._estimate_truncation_order()
        # print(f"Estimated truncation order niter = {self.niter}")

        self.fn = np.arange(1, self.niter + 1)  # Iteration indices

        self.Wn = self.calc_roughness_spectrum()  # Roughness spectrum
        # print(f"Roughness spectrum shape: {self.Wn.shape}")

    def _spherical_to_cartesian(self, k, theta, phi):
        """
        Convert spherical coordinates to Cartesian components of wavevector.
        """
        kx = k * np.sin(theta) * np.cos(phi)
        ky = k * np.sin(theta) * np.sin(phi)
        kz = k * np.cos(theta)
        
        return kx, ky, kz
    

    def compute_surface_slopes(self, kx, ky, kz, ksx, ksy, ksz):
        denominator = ksz - kz
        if np.isclose(denominator, 0.0):
            raise ValueError("Denominator ksz + kz is zero — invalid geometry or normal direction")

        zx = -(ksx - kx) / denominator
        zy = -(ksy - ky) / denominator

        # zx = -((self.sits * self.csfs) - (self.siti * self.csfi)) / (self.csts + self.csti)
        # zy = -((self.sits * self.sifs) - (self.siti * self.sifi)) / (self.csts + self.csti)
        
        return zx, zy


    def compute_sigma0(self, pol=None, todB=True):
        """
        Compute the backscattering coefficient σ0 for the specified polarization or all.

        Parameters:
        - pol (str or None): One of ['VV', 'HH', 'HV', 'VH'] or None to compute all.
        - todB (bool): Whether to return the result in decibels (dB) or linear scale.

        Returns:
        - dict: Dictionary of σ0 values for the specified polarization(s), in linear or dB.
        """
        valid_pols = ['vv', 'hh', 'hv', 'vh']
        result = {}

        if pol in valid_pols:
            # Only compute the requested polarization
            sigma0_S = self.single_scattering(pol)
            # sigma0_M = self.multiple_scattering(pol)
            sigma0 = sigma0_S #+ sigma0_M
            result[pol] = 10 * np.log10(sigma0) if todB else sigma0
            return result

        elif pol is None or pol.lower() == 'full':
            # Compute all four polarizations
            for p in valid_pols:
                sigma0_S = self.single_scattering(p)
                # sigma0_M = self.multiple_scattering(p)
                sigma0 = sigma0_S #+ sigma0_M
                result[p] = 10 * np.log10(sigma0) if todB else sigma0
            return result

        else:
            raise ValueError(f"Invalid polarization '{pol}'. Must be one of {valid_pols} or None.")


    def single_scattering(self, pol):
        
        # Reflection coefficients for the incident angle
        rvi, rhi, rvhi, rhvi = self.__reflection_coefficients_incident()

        # Reflection coefficients for the specular angle
        rvl, rhl, rvhl, rhvl = self.__reflection_coefficients_specular()

        # Reflection coefficients based on transition function
        rvtran, rhtran, rvhtran, rhvtran = self.__reflection_coefficients_transition(rvi, rhi, rvl, rhl)

        # Kirchhoff field coefficients
        fhh, fvv, fvh, fhv = VKA(theta_i=self.theta_i, phi_i=self.phi_i, theta_s=self.theta_s, phi_s=self.phi_s, Rv=rvtran, Rh=rhtran).field_coefficients()
        # fhh, fvv, fhv, fvh = self.__kirchhoff_field_coefficients(rhtran, rvtran)

        # Calculate complementary field coefficients
        Ivv, Ihh, Ihv, Ivh = self.__complementary_field_coefficients(rvi, rhi, rvhi, rhvi, fvv, fhh, fhv, fvh)

         # Calculate the backscattering coefficients
        sumVV, sumHH, sumHV, sumVH = 0.0, 0.0, 0.0, 0.0
        temp = 1.0
        
        for i in range(self.niter):
            fn = i + 1
            temp = temp * (self.ks2 / fn)
            sumVV += temp * np.abs(Ivv[i])**2 * self.Wn[i]
            sumHH += temp * np.abs(Ihh[i])**2 * self.Wn[i]
            sumHV += temp * np.abs(Ihv[i])**2 * self.Wn[i]
            sumVH += temp * np.abs(Ivh[i])**2 * self.Wn[i]

        # Calculate the final backscattering coefficients
        common_factor = 0.5 * np.exp(-self.ks2 * (self.ksz**2 + self.kz**2))
        fullPol = np.zeros(self.er.shape + (4,), dtype=float)
        fullPol[..., 0] = common_factor * sumVV
        fullPol[..., 1] = common_factor * sumHH
        fullPol[..., 2] = common_factor * sumHV
        fullPol[..., 3] = common_factor * sumVH
        

        # Return specific polarization if requested, otherwise all
        if pol == 'vv':
            return fullPol[..., 0]
        elif pol == 'hh':
            return fullPol[..., 1]
        elif pol == 'hv':
            return fullPol[..., 2]
        elif pol == 'vh':
            return fullPol[..., 3]
        elif pol is None or pol.lower() == 'all': # If no specific pol, or 'all'
            return fullPol
        else:
            # This case should ideally not be reached if pol is validated by the caller (e.g. compute_sigma0)
            # but as a safeguard:
            raise ValueError(f"Invalid polarization '{pol}' requested in single_scattering. Expected 'VV', 'HH', 'HV', 'VH', or None/all.")

    
    def __kirchhoff_field_coefficients(self, rh, rv):
        """
        Calculates the Kirchhoff (or Physical Optics) field coefficients.

        These coefficients provide an initial estimate of the scattered fields
        based on the assumption that the surface is locally flat. They are
        derived from the transition reflection coefficients and geometric factors
        related to surface slopes.

        Parameters
        ----------
        rh, rv : complex
            Transition reflection coefficients for horizontal (H) and
            vertical (V) polarizations.

        Utilizes
        ---------
        self.sis, self.csfs, self.si, self.css, self.cs, self.sfs, self.cs2, self.si2.

        Returns
        -------
        tuple of complex
            Kirchhoff field coefficients: fhh, fvv, fhv, fvh.
        """
        # zxx = -(self.sis * self.csfs - self.si) / (self.css + self.cs)
        # zyy = -(self.sis * self.sfs) / (self.css + self.cs)
        
        zxx = -((self.sits * self.csfs) - (self.siti * self.csfi)) / (self.csts + self.csti)
        zyy = -((self.sits * self.sifs) - (self.siti * self.sifi)) / (self.csts + self.csti)

        d2 = np.hypot(zxx * self.csti - self.siti, zyy)

        # Precomputed terms
        term = self.csti + self.siti * zxx

        # Field coefficients
        hsnv = -(self.csti * self.csfs + self.siti * (zxx * self.csfs + zyy * self.sifs))
        vsnh = self.csts * self.csfs - zxx * self.sits
        hsnh = -self.sifs
        vsnv = zyy * self.csti * self.sits + self.csts * (zyy * self.csfs * self.siti - term * self.sifs)

        
        # Complex terms simplified
        hsnt = ((-(self.csti2 + self.siti2) * self.sifs * (self.siti - self.csti * zxx) +
                self.csfs * term * zyy +
                self.siti * self.sifs * zyy ** 2) / d2)
        
        hsnd = (-term * (-self.csfs * self.siti + self.csti * self.csfs * zxx + self.csti * self.sifs * zyy)) / d2
        
        vsnt = (((self.csti2 + self.siti2) * (self.csti * zxx - self.siti) * (self.csfs * self.csts - self.sits * zxx) +
                self.csts * self.sifs * term * zyy -
                (self.csfs * self.csts * self.siti + self.csti * self.sits) * zyy ** 2) / d2)
        
        vsnd = -term * (self.siti * self.sits * zyy - self.csts * (self.siti * self.sifs - self.csti * self.sifs * zxx + self.csti * self.csfs * zyy)) / d2

        # Field coefficients
        # Shared ratio
        ratio = (rh + rv) * zyy / d2
        fhh = (1. - rh) * hsnv + (1. + rh) * vsnh - (hsnt + vsnd) * ratio
        fvv = -((1. - rv) * hsnv + (1. + rv) * vsnh) + (hsnt + vsnd) * ratio
        fhv = -(1. + rv) * hsnh + (1. - rv) * vsnv + (hsnd - vsnt) * ratio
        fvh = -(1. + rh) * hsnh + (1. - rh) * vsnv + (hsnd - vsnt) * ratio

        return fhh, fvv, fhv, fvh


    def multiple_scattering(self, pol):
        pass
        # Placeholder for multiple scattering calculation


    def __reflection_coefficients_transition(self, rvi, rhi, rvl, rhl):
        """
        Calculates transition reflection coefficients.

        These coefficients blend the Fresnel reflection coefficients for the
        incident direction and the specular direction using a transition function.
        The transition function depends on the surface roughness and viewing
        geometry, effectively determining how much the scattering behaves like
        specular reflection versus diffuse scattering.

        Parameters
        ----------
        rvi, rhi : complex
            Fresnel reflection coefficients for the incident wave direction
            (co-polarizations V and H).
        rvl, rhl : complex
            Fresnel reflection coefficients for the specular direction
            (co-polarizations V and H).

        Utilizes
        ---------
        self.er, self.si2, self.cs, self.iterm, self.ks, self.spectra_1.

        Returns
        -------
        tuple of complex
            Transition reflection coefficients: rvtran, rhtran, rvhtran, rhvtran.
        """

        sqrt_er = np.sqrt(self.er)
        rv0 = (sqrt_er - 1.0) / (sqrt_er + 1.0)
        rh0 = -rv0  # symmetric relation

        sqrt_term = np.sqrt(self.er - self.siti2)
        Ftv = 8.0 * rv0**2 * self.siti2 * (self.csti + sqrt_term) / (self.csti * sqrt_term)
        Fth = 8.0 * rh0**2 * self.siti2 * (self.csti + sqrt_term) / (self.csti * sqrt_term)

        st0v = 1.0 / np.abs(1.0 + (8.0 * rv0) / (self.csti * Ftv))**2
        st0h = 1.0 / np.abs(1.0 + (8.0 * rh0) / (self.csti * Fth))**2

        sum1 = 0.0
        sum2 = 0.0
        sum3 = 0.0
        temp1 = 1.0

        # Calculate the transition reflection coefficients
        # using the series expansion
        kscs = self.ks * self.csti

        for n in range(self.niter):
            fn = n+1
            temp1 = temp1 * (1. / fn)
            sum1 += temp1 * kscs**(2. * fn) * self.Wn[n]
            sum2 += temp1 * kscs**(2. * fn) * np.abs(Ftv + 2.0**(fn + 2.0) * (rv0 / self.csti) * np.exp(-kscs**2))**2 * self.Wn[n]
            sum3 += temp1 * kscs**(2. * fn) * np.abs(Fth + 2.0**(fn + 2.0) * (rh0 / self.csti) * np.exp(-kscs**2))**2 * self.Wn[n]

        # Calculate the transition reflection coefficients
        stv = np.abs(Ftv)**2 * sum1 / sum2
        sth = np.abs(Fth)**2 * sum1 / sum3
        tfv = 1.0 - stv / st0v
        tfh = 1.0 - sth / st0h
        
        # Avoid division by zero
        tfv = np.where(np.abs(tfv) < 0.0, 0.0, tfv)
        tfh = np.where(np.abs(tfh) < 0.0, 0.0, tfh)

        rvtran = rvi + (rvl - rvi) * tfv
        rhtran = rhi + (rhl - rhi) * tfh
        rvhtran = (rvtran - rhtran) / 2.0
        rhvtran = (rhtran - rvtran) / 2.0

        return rvtran, rhtran, rvhtran, rhvtran


    def __reflection_coefficients_incident(self):
        """
        Calculates Fresnel reflection coefficients for the incident wave direction.

        These coefficients describe how much of the incident wave is reflected
        at a smooth interface for vertical (V) and horizontal (H) polarizations,
        considering the incident angle `theta_i`.

        Utilizes
        ---------
        self.er, self.ur, self.si, self.cs.

        Returns
        -------
        tuple of complex
            Reflection coefficients: rvi, rhi, rvhi, rhvi.
            `rvhi` and `rhvi` are derived cross-polarization terms.
        """
        stem = np.sqrt(self.er * self.ur - self.siti2)

        rvi = (self.er * self.csti - stem) / (self.er * self.csti + stem)
        rhi = (self.ur * self.csti - stem) / (self.ur * self.csti + stem)
        rvhi = (rvi - rhi) / 2.

        return rvi, rhi, rvhi, -rvhi


    def __reflection_coefficients_specular(self):
        """
        Calculates Fresnel reflection coefficients for an "effective" specular angle.

        This method first determines an effective specular angle based on the
        incident and scattering geometry. Then, it calculates the Fresnel
        reflection coefficients for this effective angle.

        Utilizes
        ---------
        self.cs, self.css, self.si, self.sis, self.csfs, self.er, self.ur.

        Returns
        -------
        tuple of complex
            Reflection coefficients: rvl, rhl, rvhl, rhvl.
            `rvhl` and `rhvl` are derived cross-polarization terms.
        """
        csl = np.sqrt(1.0 + self.csti * self.csts - self.siti * self.sits * self.csfs) / np.sqrt(2.0)
        sil = np.sqrt(1.0 - csl**2)
        steml = np.sqrt(self.er * self.ur - sil**2)

        rvl = (self.er * csl - steml) / (self.er * csl + steml)
        rhl = (self.ur * csl - steml) / (self.ur * csl + steml)
        rvhl = (rvl - rhl) / 2.0

        return rvl, rhl, rvhl, -rvhl


    def _estimate_truncation_order(self, tol=1e-16):
        """
        Estimate truncation order Nmax using convergence of exponential series.

        Parameters:
        - tol (float): Tolerance threshold for truncation

        Returns:
        - int: Estimated maximum number of iterations (Nmax)
        """
        base = self.ks2 * (self.csti + self.csts) ** 2  # (cosθi + cosθs)^2

        iterm = 1
        temp_old = 0.0
        temp = base

        while abs(temp - temp_old) > tol:
            temp_old = temp
            iterm += 1
            temp = temp_old * base / iterm
            if iterm > 1000:
                break  # safety limit

        return iterm


    def calc_roughness_spectrum(self):

        # Compute Δk magnitude
        delta_kx = self.ksx - self.kx
        delta_ky = self.ksy - self.ky
        delta_K = self.kl * np.hypot(delta_kx, delta_ky)  # Shape: (res, res)
        # delta_K = self.kl * np.hypot(self.sits * self.csfs - self.siti * self.csfi, self.sits * self.sifs - self.siti * self.sifi)

        # Initialize W array
        W = np.zeros((self.niter, ), dtype=np.float64)

        for n in range(self.niter):
            fn = n+1
        
            if self.acf == 'gauss':
                # Gaussian autocorrelation function
                W[n] = self.kl2 / (2 * fn) * np.exp(-delta_K**2 / (4 * fn))

            elif self.acf == 'exp':
                # Exponential autocorrelation function
                W[n] = (self.kl / fn)**2 * (1.0 + (delta_K / fn)**2)**(-1.5)

            elif self.acf == 'xpow':
                e = 1.5 * fn - 1.0               # exponent of (K/2)^e
                nu = -e                          # order of modified Bessel function
                gamma_vals = gamma(1.5 * fn)     # shape (n_spec,)

                # Avoid divide-by-zero when K == 0
                DK_safe = np.where(delta_K == 0.0, 1e-12, delta_K)

                out = self.kl2 * (DK_safe / 2.0) ** e
                bessel_part = kv(nu, DK_safe)
                bessel_part = np.where(delta_K == 0.0, 1.0, bessel_part)  # K0(0) ~ 1 (custom fix)

                W[n] = out * (bessel_part / gamma_vals)
            
            else:
                raise ValueError(f"Unsupported ACF type: {self.acf}")
        
        return W


    def __complementary_field_coefficients(self, Rvi, Rhi, Rvhi, Rhvi, fvv, fhh, fhv, fvh):
        """
        Compute the total bistatic scattering field coefficients with properly
        differentiated upward/downward and air/soil components.

        Returns
        -------
        tuple of np.ndarray :
            Ivv, Ihh, Ihv, Ivh, CIvv, CIhh, CIhv, CIvh
        """
        Ivv = np.zeros(self.niter, dtype=complex)
        Ihh = np.zeros(self.niter, dtype=complex)
        Ihv = np.zeros(self.niter, dtype=complex)
        Ivh = np.zeros(self.niter, dtype=complex)

        # Compute all F and G contributions explicitly and name them clearly
        qi = np.sqrt(self.k2 + self.kx**2 + self.ky**2)
        qt = np.sqrt(self.k2 * self.er - self.kx**2 - self.ky**2)
        q = qi

        # VV polarization
        Fvvupi = self.compute_F_qp('VV', -self.kx, -self.ky, q, qi, qt, Rvi) * self.exp_soil_decay(self.kz, direction='+')
        Fvvups = self.compute_F_qp('VV', -self.ksx, -self.ksy, q, qi, qt, Rvi) * self.exp_soil_decay(self.kz, direction='+')
        Fvvdni = self.compute_F_qp('VV', -self.kx, -self.ky, q, qi, -qt, Rvi) * self.exp_soil_decay(self.kz, direction='-')
        Fvvdns = self.compute_F_qp('VV', -self.ksx, -self.ksy, q, qi, -qt, Rvi) * self.exp_soil_decay(self.kz, direction='-')
        
        Gvvupi = self.compute_G_qp('VV', -self.kx, -self.ky, q, qi, qt, Rvi) * self.exp_soil_decay(qt, direction='+')
        Gvvups = self.compute_G_qp('VV', -self.ksx, -self.ksy, q, qi, qt, Rvi) * self.exp_soil_decay(qt, direction='+')
        Gvvdni = self.compute_G_qp('VV', -self.kx, -self.ky, q, qi, -qt, Rvi) * self.exp_soil_decay(qt, direction='-')
        Gvvdns = self.compute_G_qp('VV', -self.ksx, -self.ksy, q, qi, -qt, Rvi) * self.exp_soil_decay(qt, direction='-')

        # HH polarization
        Fhhupi = self.compute_F_qp('HH', -self.kx, -self.ky, q, qi, qt, Rhi) * self.exp_soil_decay(self.kz, direction='+')
        Fhhups = self.compute_F_qp('HH', -self.ksx, -self.ksy, q, qi, qt, Rhi) * self.exp_soil_decay(self.kz, direction='+')
        Fhhdni = self.compute_F_qp('HH', -self.kx, -self.ky, q, qi, -qt, Rhi) * self.exp_soil_decay(self.kz, direction='-')
        Fhhdns = self.compute_F_qp('HH', -self.ksx, -self.ksy, q, qi, -qt, Rhi) * self.exp_soil_decay(self.kz, direction='-')
        
        Ghhupi = self.compute_G_qp('HH', -self.kx, -self.ky, q, qi, qt, Rhi) * self.exp_soil_decay(qt, direction='+')
        Ghhups = self.compute_G_qp('HH', -self.ksx, -self.ksy, q, qi, qt, Rhi) * self.exp_soil_decay(qt, direction='+')
        Ghhdni = self.compute_G_qp('HH', -self.kx, -self.ky, q, qi, -qt, Rhi) * self.exp_soil_decay(qt, direction='-')
        Ghhdns = self.compute_G_qp('HH', -self.ksx, -self.ksy, q, qi, -qt, Rhi) * self.exp_soil_decay(qt, direction='-')


        # HV polarization
        Fhvupi = self.compute_F_qp('HV', -self.kx, -self.ky, q, qi, qt, Rhvi) * self.exp_soil_decay(self.kz, direction='+')
        Fhvups = self.compute_F_qp('HV', -self.ksx, -self.ksy, q, qi, qt, Rhvi) * self.exp_soil_decay(self.kz, direction='+')
        Fhvdni = self.compute_F_qp('HV', -self.kx, -self.ky, q, qi, -qt, Rhvi) * self.exp_soil_decay(self.kz, direction='-')
        Fhvdns = self.compute_F_qp('HV', -self.ksx, -self.ksy, q, qi, -qt, Rhvi) * self.exp_soil_decay(self.kz, direction='-')
        
        Ghvupi = self.compute_G_qp('HV', -self.kx, -self.ky, q, qi, qt, Rhvi) * self.exp_soil_decay(qt, direction='+')
        Ghvups = self.compute_G_qp('HV', -self.ksx, -self.ksy, q, qi, qt, Rhvi) * self.exp_soil_decay(qt, direction='+')
        Ghvdni = self.compute_G_qp('HV', -self.kx, -self.ky, q, qi, -qt, Rhvi) * self.exp_soil_decay(qt, direction='-')
        Ghvdns = self.compute_G_qp('HV', -self.ksx, -self.ksy, q, qi, -qt, Rhvi) * self.exp_soil_decay(qt, direction='-')


        # VH polarization
        Fvhupi = self.compute_F_qp('VH', -self.kx, -self.ky, q, qi, qt, Rvhi) * self.exp_soil_decay(self.kz, direction='+')
        Fvhups = self.compute_F_qp('VH', -self.ksx, -self.ksy, q, qi, qt, Rvhi) * self.exp_soil_decay(self.kz, direction='+')
        Fvhdni = self.compute_F_qp('VH', -self.kx, -self.ky, q, qi, -qt, Rvhi) * self.exp_soil_decay(self.kz, direction='-')
        Fvhdns = self.compute_F_qp('VH', -self.ksx, -self.ksy, q, qi, -qt, Rvhi) * self.exp_soil_decay(self.kz, direction='-')
        
        Gvhupi = self.compute_G_qp('VH', -self.kx, -self.ky, q, qi, qt, Rvhi) * self.exp_soil_decay(qt, direction='+')
        Gvhups = self.compute_G_qp('VH', -self.ksx, -self.ksy, q, qi, qt, Rvhi) * self.exp_soil_decay(qt, direction='+')
        Gvhdni = self.compute_G_qp('VH', -self.kx, -self.ky, q, qi, -qt, Rvhi) * self.exp_soil_decay(qt, direction='-')
        Gvhdns = self.compute_G_qp('VH', -self.ksx, -self.ksy, q, qi, -qt, Rvhi) * self.exp_soil_decay(qt, direction='-')

        # # Apply cross-pol scaling factor
        cross_pol_scale = 22500
        fvh = fvh * cross_pol_scale
        fhv = fhv * cross_pol_scale

        # fvh *= self.k2 / 64 * np.pi
        # fhv *= self.k2 / 64 * np.pi

        for n in range(self.niter):
            fn = n + 1
            Ivv[n] = (self.ksz + self.kz)**fn * fvv * np.exp(-self.ks2 * self.kz * self.ksz) 
            # + 0.25 * (
            #     Fvvupi * (self.ksz - self.kz) ** fn + 
            #     Fvvups * (self.ksz - self.kz) ** fn +
            #     Fvvdni * (self.ksz + self.kz) ** fn +
            #     Fvvdns * (self.ksz + self.kz) ** fn +
            #     Gvvupi * (self.ksz - qt) ** fn +
            #     Gvvups * (self.ksz - qt) ** fn +
            #     Gvvdni * (self.ksz + qt) ** fn +
            #     Gvvdns * (self.ksz + qt) ** fn
            # )

            Ihh[n] = (self.ksz + self.kz)**fn * fhh * np.exp(-self.ks2 * self.kz * self.ksz) 
            # + 0.25 * (
            #     Fhhupi * (self.ksz - self.kz) ** fn + 
            #     Fhhups * (self.ksz - self.kz) ** fn +
            #     Fhhdni * (self.ksz + self.kz) ** fn +
            #     Fhhdns * (self.ksz + self.kz) ** fn +
            #     Ghhupi * (self.ksz - qt) ** fn +
            #     Ghhups * (self.ksz - qt) ** fn +
            #     Ghhdni * (self.ksz + qt) ** fn +
            #     Ghhdns * (self.ksz + qt) ** fn
            # )

            Ihv[n] = (self.ksz + self.kz)**fn * fhv * np.exp(-self.ks2 * self.kz * self.ksz) 
            # + 0.25 * (
            #     Fhvupi * (self.ksz - self.kz) ** fn + 
            #     Fhvups * (self.ksz - self.kz) ** fn +
            #     Fhvdni * (self.ksz + self.kz) ** fn +
            #     Fhvdns * (self.ksz + self.kz) ** fn +
            #     Ghvupi * (self.ksz - qt) ** fn +
            #     Ghvups * (self.ksz - qt) ** fn +
            #     Ghvdni * (self.ksz + qt) ** fn +
            #     Ghvdns * (self.ksz + qt) ** fn
            # )

            Ivh[n] = (self.ksz + self.kz)**fn * fvh * np.exp(-self.ks2 * self.kz * self.ksz) 
            # + 0.25 * (
            #     Fvhupi * (self.ksz - self.kz) ** fn + 
            #     Fvhups * (self.ksz - self.kz) ** fn +
            #     Fvhdni * (self.ksz + self.kz) ** fn +
            #     Fvhdns * (self.ksz + self.kz) ** fn +
            #     Gvhupi * (self.ksz - qt) ** fn +
            #     Gvhups * (self.ksz - qt) ** fn +
            #     Gvhdni * (self.ksz + qt) ** fn +
            #     Gvhdns * (self.ksz + qt) ** fn
            # )

        return Ivv, Ihh, Ihv, Ivh


    def exp_soil_decay(self, q, direction='+'):
        """
        Computes the exponential decay component for the soil-transmitted wave
        in the complementary field term of the AIEM model.

        Parameters
        ----------
        

        Returns
        -------
        np.ndarray
            The exponential decay factor due to roughness for the soil term.
        """
        if direction == '+':
            return np.exp(-self.s2 * (q**2 - q * (self.ksz - self.kz)))
        elif direction == '-':
            return np.exp(-self.s2 * (q**2 + q * (self.ksz - self.kz)))
        else:
            raise ValueError("Invalid direction. Must be '+' or '-'.")


    def compute_F_qp(self, pol, u, v, q, qslp, qfix, R):
        """
        General function to compute F_pp^± for VV, HH, VH, HV polarizations.

        Parameters:
        - pol: 'VV', 'HH', 'VH', or 'HV'
        - R: Reflection coefficient (Rv, Rh, or R for cross-pols)
        - q: Incident wave projection qi
        - C_vals: tuple of C1 to C6 values (for VV, HH)
        - B_vals: tuple of B1 to B6 values (for VH, HV); optional for VV/HH
        - direction: '+' or '-', for upward (+) or downward (−) propagation

        Returns:
        - F_pp^± value
        """

        # Check if is co-pol
        if pol in ['VV', 'HH']:
            C1i, C2i, C3i, C4i, C5i, C6i = self.compute_C_coefficients(u, v, qslp, q)
        elif pol in ['VH', 'HV']:
            B1i, B2i, B3i, B4i, B5i, B6i = self.compute_B_coefficients(u, v, qslp, q)
        
        if pol == 'VV':
            F = (-(1 - R)*(1 + R)*C1i +
                (1 - R)**2 * C2i +
                (1 - R)*(1 + R)*C3i +
                (1 + R)*(1 - R)*C4i +
                (1 + R)**2 * C5i +
                (1 + R)*(1 - R)*C6i) / qfix

        elif pol == 'HH':
            F = ((1 - R)*(1 + R)*C1i -
                (1 - R)**2 * C2i -
                (1 - R)*(1 + R)*C3i -
                (1 + R)*(1 - R)*C4i -
                (1 + R)**2 * C5i -
                (1 + R)*(1 - R)*C6i) / qfix

        elif pol == 'HV':
            F = ((1 - R)*(1 + R)*B1i +
                (1 - R)**2 * B2i -
                (1 - R)*(1 + R)*B3i +
                (1 + R)*(1 - R)*B4i +
                (1 + R)**2 * B5i -
                (1 + R)*(1 - R)*B6i) / qfix

        elif pol == 'VH':
            F = ((1 + R)*(1 - R)*B1i -
                (1 + R)**2 * B2i -
                (1 + R)*(1 - R)*B3i +
                (1 - R)*(1 + R)*B4i +
                (1 - R)**2 * B5i +
                (1 - R)*(1 + R)*B6i) / qfix

        else:
            raise ValueError("Polarization must be 'VV', 'HH', 'VH', or 'HV'.")

        return F
    

    def compute_G_qp(self, pol, u, v, q, qslp, qfix, R):
        """
        General function to compute G_pp^± for VV, HH, VH, HV polarizations.

        Parameters:
        - pol: 'VV', 'HH', 'VH', or 'HV'
        - R: Reflection coefficient (Rv, Rh, or R for cross-pols)
        - qt: Transmitted wave projection q_t
        - er: Relative permittivity ε_r
        - ur: Relative permeability μ_r
        - C_vals: tuple of C1t to C6t (for VV, HH)
        - B_vals: tuple of B1t to B6t (for VH, HV)
        - direction: '+' or '-' for upward/downward

        Returns:
        - G_pp^± value
        """

        # Check if is co-pol
        if pol in ['VV', 'HH']:
            C1t, C2t, C3t, C4t, C5t, C6t = self.compute_C_coefficients(u, v, qslp, q)
        elif pol in ['VH', 'HV']:
            B1t, B2t, B3t, B4t, B5t, B6t = self.compute_B_coefficients(u, v, qslp, q)

        if pol == 'VV':
            G = (
                ((1 + R) * self.ur * (1 + R) * C1t) -
                ((1 + R) * (1 - R) * C2t) -
                ((1 + R) * (1 + R) * C3t) / self.er -
                ((1 - R) * self.er * (1 - R) * C4t) -
                ((1 - R) * (1 + R) * C5t) -
                ((1 - R) * (1 - R) * C6t) / self.ur
            ) / qfix

        elif pol == 'HH':
            G = (
                -((1 + R) * self.er * (1 + R) * C1t) +
                ((1 + R) * (1 - R) * C2t) -
                ((1 + R) * (1 + R) * C3t) / self.ur +
                ((1 + R) * self.ur * (1 - R) * C4t) +
                ((1 - R) * (1 + R) * C5t) -
                ((1 - R) * (1 - R) * C6t) / self.er
            ) / qfix

        elif pol == 'HV':
            G = (
                -((1 + R) * self.ur * (1 + R) * B1t) +
                ((1 + R) * (1 - R) * B2t) +
                ((1 + R) * (1 + R) * B3t) / self.er -
                ((1 - R) * self.er * (1 - R) * B4t) +
                ((1 - R) * (1 + R) * B5t) +
                ((1 - R) * (1 - R) * B6t) / self.ur
            ) / qfix

        elif pol == 'VH':
            G = (
                -((1 - R) * self.er * (1 - R) * B1t) +
                ((1 - R) * (1 + R) * B2t) +
                ((1 - R) * (1 - R) * B3t) / self.ur -
                ((1 + R) * self.ur * (1 + R) * B4t) -
                ((1 + R) * (1 - R) * B5t) -
                ((1 + R) * (1 + R) * B6t) / self.er
            ) / qfix

        else:
            raise ValueError("Polarization must be 'VV', 'HH', 'VH', or 'HV'.")

        return G


    def compute_C_coefficients(self, u, v, q, q1):
        
        cos_phi_diff = np.cos(self.phi_s - self.phi_i)
        sin_phi_diff = np.sin(self.phi_s - self.phi_i)

        C1 = cos_phi_diff * (1. - ((self.ksx + u)*(self.kx + u)) / ((self.ksz - q)*(self.kz + q))) \
            - sin_phi_diff * ((self.kz + q)*(self.ksy + v)) / ((self.ksz - q)*(self.kz + q))

        C2 = -cos_phi_diff * (
            -q * self.csti
            + (u * self.csti * (self.ksx + u)) / (self.ksz - q)
            - (q1 * self.siti * (self.kx + u)) / (self.kz + q)
            + (u * self.siti * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q) * (self.kz + q))
            - (v * self.csti * (self.ky + v)) / (self.kz + q)
            + (v * self.siti * (self.ksx + u) * (self.ky + v)) / ((self.ksz - q) * (self.kz + q))
        ) + sin_phi_diff * (
            -(u * self.csti * (self.ksy + v)) / (self.ksz - q)
            - (u * self.siti * (self.kx + u) * (self.ksy + v)) / ((self.ksz - q)*(self.kz + q))
            + (q1 * self.siti * (self.ky + v)) / (self.kz + q)
            - (u * self.csti * (self.ky + v)) / (self.kz + q)
            - (v * self.siti * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
        )

        C3 = (-(self.kz + q) * self.siti + (self.kx + u) * self.csti
            + (self.ksx * q * cos_phi_diff + self.ksy * q * sin_phi_diff)) / ((self.ksz - q)*(self.kz + q))

        C4 = self.csts * sin_phi_diff * (
                (self.siti * (self.ky + v)) / (self.kz + q)
                + (self.csti * (self.ksx + u) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
            ) + self.csts * cos_phi_diff * (
                self.csti + (self.siti * (self.kx + u)) / (self.kz + q)
                - (self.csti * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
            ) + self.sits * (
                (self.csti * (self.ksx + u)) / (self.ksz - q)
                + (self.siti * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
                + (self.siti * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
            )

        C5 = -self.csts * sin_phi_diff * (
                ((self.ksx + u) * v) / (self.ksz - q)
                + ((self.kx + u) * v) / (self.kz + q)
            ) - self.csts * cos_phi_diff * (
                q + ((self.kx + u) * u) / (self.kz + q)
                - ((self.ksy + v) * v) / (self.ksz - q)
            ) - self.sits * (
                (q1 * (self.ksx + u)) / (self.ksz - q)
                + (u * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
                + (v * (self.ksy + v) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
            )

        C6 = self.csts * sin_phi_diff * (
                (q * (self.ksx + u) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
                + (u * (self.ky + v)) / (self.kz + q)
            ) - self.csts * cos_phi_diff * (
                (q1 * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
                + (v * (self.ky + v)) / (self.kz + q)
            ) + self.sits * (
                (u * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
                - (u * (self.ksx + u) * (self.kx + v)) / ((self.ksz - q)*(self.kz + q))
            )

        return C1, C2, C3, C4, C5, C6


    def compute_B_coefficients(self, u, v, q, q1):
        
        cos_phi_diff = np.cos(self.phi_s - self.phi_i)
        sin_phi_diff = np.sin(self.phi_s - self.phi_i)

        B1 = self.csts * sin_phi_diff * (
            1 - (q * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q) * (self.kz + q))
        ) + self.csts * cos_phi_diff * (
            (self.sits * self.ksx + (self.ksy + v)) / (self.ksz - q)
            * ((self.kx + u) * (self.ksy + v)) / ((self.ksz - q) * (self.kz + q))
        )

        B2 = self.csts * sin_phi_diff * (
            q * self.csti
            - (u * self.csti * (self.ksx + u)) / (self.ksz - q)
            + (q * self.siti * (self.kx + u)) / (self.kz + q)
            - (u * self.siti * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
            + (v * self.csti * (self.ky + v)) / (self.kz + q)
            - (v * self.siti * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
        ) + self.sits * (
            (q * self.csti * (self.ksy + v)) / (self.ksz - q)
            + (q1 * self.siti * (self.kx + u) * (self.ksy + v)) / ((self.ksz - q)*(self.kz + q))
            + (q1 * self.siti * (self.ksx + u) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
            + (u * self.csti * (self.ksx + u) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
            + (v * self.csti * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
        ) + self.csts * cos_phi_diff * (
            (q * self.csti * (self.ksy + v)) / (self.ksz - q)
            + (u * self.siti * (self.kx + u) * (self.ksy + v)) / ((self.ksz - q)*(self.kz + q))
            - (q * self.siti * (self.ky + v)) / (self.kz + q)
            + (u * self.csti * (self.ky + v)) / (self.kz + q)
            + (v * self.siti * (self.ky + v) * (self.ksy + v)) / ((self.ksz - q)*(self.kz + q))
        )

        B3 = -self.csts * sin_phi_diff * (
            (q * self.siti * (self.ksx + u)) / (self.ksz - q)
            + u * self.siti
            - (q * self.csti * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
            - (u * self.csti * (self.kx + u)) / (self.kz + q)
        ) + self.csts * cos_phi_diff * (
            (q1 * self.siti * (self.ksy + v)) / (self.ksz - q)
            + v * self.siti
            - (q1 * self.csti * (self.ksy + v) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
            - (v * self.csti * (self.kx + u)) / (self.kz + q)
        ) - self.sits * (
            (u * self.siti * (self.ksy + v)) / (self.kz - q)
            - (u * self.csti * (self.ksy + v) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
            - (v * self.siti * (self.ksx + u)) / (self.ksz - q)
            + (v * self.csti * (self.ksx + u) * (self.kx + u)) / ((self.ksz - q)*(self.kz + q))
        )

        B4 = cos_phi_diff * (
            (self.siti * (self.ky + v)) / (self.kz + q)
            + (self.csti * (self.ksx + u) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
        ) - sin_phi_diff * (
            self.csti
            + (self.siti * (self.kx + u)) / (self.kz + q)
            - (self.csti * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
        )

        B5 = -cos_phi_diff * (
            (v * (self.ksx + u)) / (self.ksz - q)
            + (v * (self.kx + u)) / (self.kz + q)
        ) + sin_phi_diff * (
            q - (v * (self.ksy + v)) / (self.ksz - q)
            - (u * (self.kx + u)) / (self.kz + q)
        )

        B6 = cos_phi_diff * (
            (q * (self.ksx + u) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
            + (u * (self.ky + v)) / (self.kz + q)
        ) + sin_phi_diff * (
            (q * (self.ksy + v) * (self.ky + v)) / ((self.ksz - q)*(self.kz + q))
            + (v * (self.ky + v)) / (self.kz + q)
        )

        return B1, B2, B3, B4, B5, B6




# Example usage
if __name__ == "__main__":
    # Example parameters
    frq_GHz = 5.405  # Frequency in GHz
    acf = 'gauss'
    s = 0.01
    l = 0.05
    thi_deg = 30.0
    ths_deg = 30.0
    phi_deg = 0.0
    phs_deg = 180.0
    eps = np.array([2.5 + 1j * 0.01, ], dtype=complex)

    # Create AIEM instance
    aiem_model = AIEM0(frq_GHz, acf, s, l, eps, thi_deg, ths_deg, phi_deg, phs_deg)
    print("AIEM model initialized.")

    # Compute backscattering coefficient for VV polarization
    sigma0 = aiem_model.compute_sigma0(pol='full', todB=True)
    print("Backscattering coefficient (dB) for full polarization:", sigma0)