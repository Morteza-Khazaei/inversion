import numpy as np
# from ka import KirchhoffApproximation as KA
from ka import VectorizedKirchhoffApproximation as VKA
from scipy.special import gamma, kv, factorial



class AIEM:
    """
    Implements the Advanced Integral Equation Model (AIEM) for predicting
    radar backscattering from randomly rough dielectric surfaces.

    The AIEM is a sophisticated theoretical model widely used in microwave
    remote sensing. It calculates the Normalized Radar Cross-Section (NRCS),
    often denoted as sigma-naught (σ⁰), for various polarization combinations
    (VV, HH, HV, VH).

    The model accounts for:
    - The frequency of the incident radar wave.
    - The geometry of illumination and observation (incidence and scattering angles).
    - The physical properties of the surface:
        - Roughness, characterized by the Root Mean Square (RMS) height and
          the surface correlation length.
        - The complex relative dielectric constant (permittivity) of the
          surface material.
        - The type of autocorrelation function (ACF) describing the surface
          roughness (e.g., Gaussian, Exponential).

    This implementation breaks down the complex AIEM calculations into several
    key steps, including the determination of Fresnel reflection coefficients,
    Kirchhoff field coefficients, and the crucial complementary field
    coefficients, all combined with the surface roughness spectrum to derive
    the final backscattering coefficients.
    """
    
    def __init__(self, frq_ghz, theta_i, theta_s, phi_i, phi_s, s, l, eps, acf_type):
        """
        Initializes the AIEM model with the given input parameters.

        Parameters:
        ----------
        frq_ghz : float
            Frequency of the incident radar wave in Gigahertz (GHz).
        theta_i : float
            Incidence zenith angle [deg].
        theta_s : float
            Scattering zenith angle [deg].
        phi_i : float
            Incidence azimuth angle [deg].
        phi_s : float
            Scattering azimuth angle [deg].
        sigma : float
            Root mean square (RMS) height of the surface roughness [m].
        cl : float
            Surface correlation length [m].
        eps : complex
            Complex relative permittivity of the surface.
        acf_type : str
            Type of autocorrelation function (ACF) for the surface roughness.
            Valid options are 'gauss' for Gaussian, 'exp' for Exponential,
            and 'pow' for a 1.5 power-law ACF.
        """

        self.er = eps
        self.ur = 1
        self.itype = str(acf_type)
        theta_i = np.deg2rad(theta_i)  # Convert to radians
        theta_s = np.deg2rad(theta_s)
        phi_i = np.deg2rad(phi_i)
        phi_s = np.deg2rad(phi_s)

        self.frq_ghz = frq_ghz
        self.theta_i = theta_i
        self.theta_s = theta_s
        self.phi_i = phi_i
        self.phi_s = phi_s


        lam = self.__wavelength(frq_ghz)  # wavelength [m]
        self.k = 2 * np.pi / lam  # angular wavenumber [rad/m]

        # Roughness parameters
        self.ks = self.k * s # rms height [m]
        self.kl = self.k * l # autocorrelation length [m]
        # print(f'ks: {self.ks}, kl: {self.kl}')

        # Pre-compute trigonometric values
        self.si = np.sin(theta_i)
        self.sis = np.sin(theta_s)
        self.sfi = np.sin(phi_i)
        self.sfs = np.sin(phi_s)
        self.cs = np.cos(theta_i)
        self.css = np.cos(theta_s)
        self.csfi = np.cos(phi_i)
        self.csfs = np.cos(phi_s)

        self.cs2 = self.cs**2
        self.css2 = self.css**2
        self.si2 = self.si**2
        self.sis2 = self.sis**2
        self.ks2 = self.ks**2
        self.kl2 = self.kl**2

        # Compute roughness spectrum
        self.iterm, self.spectra_1 = self.__roughness_spectrum()

        return None


    def run(self, todB=True):
        """
        Executes the full AIEM calculation to compute backscattering coefficients.

        This method orchestrates the sequence of calculations required by the
        AIEM theory to determine the Normalized Radar Cross-Section (NRCS, σ⁰)
        for VV, HH, HV, and VH polarizations.

        The calculation steps are:
        1. Calculate Fresnel reflection coefficients for the incident direction.
        2. Calculate Fresnel reflection coefficients for the specular direction.
        3. Calculate transition reflection coefficients (blending incident/specular).
        4. Calculate Kirchhoff field coefficients.
        5. Calculate complementary field coefficients (the "Advanced" part).
        6. Combine all coefficients and the roughness spectrum to get σ⁰.

        Parameters
        ----------
        todB : bool, optional
            If True (default), the output backscattering coefficients are
            converted to decibels (dB). Otherwise, they are returned in
            linear scale.

        Returns
        -------
        tuple of float
            A tuple containing the backscattering coefficients (σ⁰) in the
            order (VV, HH, HV, VH). Values are in dB if `todB` is True,
            otherwise linear.
        """

        # Reflection coefficients for the incident angle
        rvi, rhi, rvhi, rhvi = self.__reflection_coefficients_incident()

        # Reflection coefficients for the specular angle
        rvl, rhl, rvhl, rhvl = self.__reflection_coefficients_specular()

        # Reflection coefficients based on transition function
        rvtran, rhtran, rvhtran, rhvtran = self.__reflection_coefficients_transition(rvi, rhi, rvl, rhl)

        # Kirchhoff field coefficients
        # fhh, fvv, fhv, fvh = self.__kirchhoff_field_coefficients(rhtran, rvtran)
        fhh, fvv, fhv, fvh = VKA(theta_i=self.theta_i, theta_s=self.theta_s, phi_i=self.phi_i, phi_s=self.phi_s, Rh=rhtran, Rv=rvtran).field_coefficients()

        # Calculate complementary field coefficients
        Ivv, Ihh, Ihv, Ivh, CIvv, CIhh, CIhv, CIvh = self.__complementary_field_coefficients(rvi, rhi, rvhi, rhvi, fvv, fhh, fhv, fvh)
        
        # Calculate backscattering
        sigma0 = self.__calculate_sigma0(Ivv, Ihh, Ihv, Ivh, CIvv, CIhh, CIhv, CIvh)

        # todB
        if todB:
            sigma0 = self.__todB(sigma0)

        return sigma0


    def __wavelength(self, f):
        """
        Calculates the wavelength of the electromagnetic wave.

        Parameters
        ----------
        f : float
            Frequency of the wave in Gigahertz (GHz).

        Returns
        -------
        float
            Wavelength in meters [m].
        """
        c0 = 299792458.  # speed of light [m/s]
        return c0 / (f * 1.0e9)


    def __todB(self, sigma):
        """
        Converts a linear value to decibels (dB).

        Parameters
        ----------
        sigma : float or numpy.ndarray
            The linear scale value(s) (e.g., backscattering coefficient).

        Returns
        -------
        float or numpy.ndarray
            The corresponding value(s) in decibels, calculated as 10 * log10(sigma).
        """
        return 10 * np.log10(sigma)


    def __roughness_spectrum(self,):
        """
        Calculates the surface roughness power spectrum.

        This method first performs a convergence check for a series expansion
        related to the surface roughness. Then, it calculates the roughness
        power spectrum based on the chosen autocorrelation function type (`self.itype`).

        Returns
        -------
        iterm : int
            The number of terms determined for the series convergence.
        spectra_vals : numpy.ndarray
            The calculated roughness power spectrum values corresponding to each term.
        """
        # Step 1: Convergence check
        torlant = 1e-16
        temp = self.ks2 * (self.cs + self.css)**2
        iterm = 1
        while True:
            tempold = temp
            iterm += 1
            temp *= (self.ks2 * (self.cs + self.css)**2) / iterm
            if abs(temp - tempold) <= torlant:
                break

        # Step 2: Roughness spectrum calculation
        fn = np.arange(1, iterm + 1)
        K = self.kl * np.hypot(self.sis * self.csfs - self.si * self.csfi, self.sis * self.sfs - self.si * self.sfi)

        if self.itype == 'gauss':  # Gaussian
            spectra_vals = 0.5 * self.kl2 * np.exp(-K**2 / (4 * fn)) / fn
        elif self.itype == 'exp':  # Exponential
            K_fn = K / fn
            spectra_vals = (self.kl / fn)**2 / (1 + K_fn**2)**1.5
        elif self.itype == 'xpow':  # 1.5 power-law
            fn3 = 1.5 * fn
            m = fn3 - 1
            out = self.kl**2 * (K / 2)**m
            gam = np.log(gamma(fn3))
            with np.errstate(divide='ignore', invalid='ignore'):
                bk = np.where(K == 0.0, 0.0, np.log(kv(-m, K)))
            spectra_vals = np.where(K == 0.0, self.kl**2 / (3 * fn - 2), out * np.exp(bk - gam))

        return iterm, spectra_vals


    def __calculate_sigma0(self, Ivv, Ihh, Ihv, Ivh, CIvv, CIhh, CIhv, CIvh):
        """
        Computes the final backscattering coefficients (σ⁰).

        This method combines the complementary field coefficients (I-terms)
        and their conjugates with the surface roughness spectrum and other
        model parameters to calculate the Normalized Radar Cross-Section (NRCS)
        for VV, HH, HV, and VH polarizations.

        Parameters
        ----------
        Ivv, Ihh, Ihv, Ivh : numpy.ndarray
            Complementary field coefficients for VV, HH, HV, VH polarizations.
        CIvv, CIhh, CIhv, CIvh : numpy.ndarray
            Complex conjugates of the complementary field coefficients.

        Utilizes
        ---------
        self.iterm, self.ks2, self.spectra_1, self.cs2, self.css2

        Returns
        -------
        tuple of float
            A tuple containing the calculated backscattering coefficients (σ⁰)
            in linear scale, in the order (VV, HH, HV, VH).
        """

        # Calculate the backscattering coefficients
        sum1, sum2, sum3, sum4 = 0.0, 0.0, 0.0, 0.0
        temp = 1.0
        
        for n in range(self.iterm):
            fn = n + 1
            temp = temp * (self.ks2 / fn)
            sum1 += temp * np.abs(Ivv[n] * CIvv[n]) * self.spectra_1[n]
            sum2 += temp * np.abs(Ihh[n] * CIhh[n]) * self.spectra_1[n]
            sum3 += temp * np.abs(Ihv[n] * CIhv[n]) * self.spectra_1[n]
            sum4 += temp * np.abs(Ivh[n] * CIvh[n]) * self.spectra_1[n]

        # Calculate the final backscattering coefficients
        common_factor = 0.5 * np.exp(-self.ks2 * (self.cs2 + self.css2))
        allterm = np.zeros(self.er.shape + (4,), dtype=complex)
        allterm[..., 0] = common_factor * sum1
        allterm[..., 1] = common_factor * sum2
        allterm[..., 2] = common_factor * sum3
        allterm[..., 3] = common_factor * sum4
        
        sigma0 = np.real(allterm)

        return sigma0
    

    # Define the field sum function
    def __field_sum(self, terms, field, fn, qq1, qq2, qq3, qq4):
        """
        Computes the sum of field coefficients for a given term.
        This function is used to calculate the complementary field coefficients
        in the AIEM model.
        Parameters
        ----------
        terms : tuple
            A tuple containing the scattering terms (A1, A2, A3, A4, B1, B2, B3, B4).
        field : complex
            The field coefficient (fvv, fhh, fhv, fvh).
        fn : int
            The current term number.
        qq1, qq2, qq3, qq4 : complex
            Precomputed terms related to the surface roughness and dielectric properties.
        Returns
        -------
        complex
            The sum of field coefficients for the current term.
        """
        A1, A2, A3, A4, B1, B2, B3, B4 = terms
        base_term = ((self.cs + self.css) ** fn) * np.exp(-self.ks2 * self.cs * self.css)
        return (
            base_term * field +
            0.25 * (
                A1 * ((self.css - qq1) ** fn) +
                A2 * ((self.css + qq1) ** fn) +
                A3 * ((self.cs + qq2) ** fn) +
                A4 * ((self.cs - qq2) ** fn) +
                B1 * ((self.css - qq3) ** fn) +
                B2 * ((self.css + qq3) ** fn) +
                B3 * ((self.cs + qq4) ** fn) +
                B4 * ((self.cs - qq4) ** fn)
            )
        )


    def __complementary_field_coefficients(self, rvi, rhi, rvhi, rhvi, fvv, fhh, fhv, fvh):
        """
        Calculates the complementary field coefficients (I-terms) and their conjugates.

        These coefficients are a crucial part of the "Advanced" Integral
        Equation Model, refining the Kirchhoff approximation. They are
        expressed as series expansions involving various scattering terms
        (Fa and Fb functions) and exponential factors related to surface phase
        variations.

        Parameters
        ----------
        rvi, rhi, rvhi, rhvi : complex
            Fresnel reflection coefficients for the incident wave direction
            (co- and cross-polarizations).
        fvv, fhh, fhv, fvh : complex
            Kirchhoff field coefficients for VV, HH, HV, VH polarizations.

        Utilizes
        ---------
        self.cs, self.css, self.er, self.si2, self.sis2, self.sis, self.csfs,
        self.sfs, self.iterm, self.ks2, and methods _expal, _favv, _fbvv, etc.

        Returns
        -------
        tuple of numpy.ndarray
            Eight arrays: Ivv, Ihh, Ihv, Ivh, CIvv, CIhh, CIhv, CIvh.
        """
        # Precompute constants and exponentials
        qq = self.cs
        qqt = np.sqrt(self.er - self.si2)
        qqs = self.css
        qqts = np.sqrt(self.er - self.sis2)

        qq1 = qq
        qq2 = qqs
        qq3 = qqt
        qq4 = qqts
        qq5 = qqt
        qq6 = qqts

        exp_qq1, exp_qq1_neg = self.__expal(qq1), self.__expal(-qq1)
        exp_qq2, exp_qq2_neg = self.__expal(qq2), self.__expal(-qq2)
        exp_qq5, exp_qq5_neg = self.__expal(qq5), self.__expal(-qq5)
        exp_qq6, exp_qq6_neg = self.__expal(qq6), self.__expal(-qq6)

        sis_csfs, sis_sfs = self.sis * self.csfs, self.sis * self.sfs

        # Compute all required scattering terms once
        def compute_terms(func_a, func_b, arg):
            Fa_upi = func_a(-self.si, 0.0, qq1, qq1, qq, arg) * exp_qq1
            Fa_dni = func_a(-self.si, 0.0, -qq1, -qq1, qq, arg) * exp_qq1_neg
            Fa_ups = func_a(-sis_csfs, -sis_sfs, qq2, qq2, qqs, arg) * exp_qq2
            Fa_dns = func_a(-sis_csfs, -sis_sfs, -qq2, -qq2, qqs, arg) * exp_qq2_neg
            Fb_upi = func_b(-self.si, 0.0, qq3, qq5, qqt, arg) * exp_qq5
            Fb_dni = func_b(-self.si, 0.0, -qq3, -qq5, qqt, arg) * exp_qq5_neg
            Fb_ups = func_b(-sis_csfs, -sis_sfs, qq4, qq6, qqts, arg) * exp_qq6
            Fb_dns = func_b(-sis_csfs, -sis_sfs, -qq4, -qq6, qqts, arg) * exp_qq6_neg
            
            return np.array([Fa_upi, Fa_dni, Fa_ups, Fa_dns, Fb_upi, Fb_dni, Fb_ups, Fb_dns])
        
        # Compute the scattering terms for each polarization
        vv_terms = compute_terms(self.__favv, self.__fbvv, rvi)
        hh_terms = compute_terms(self.__fahh, self.__fbhh, rhi)
        hv_terms = compute_terms(self.__fahv, self.__fbhv, rhvi)
        vh_terms = compute_terms(self.__favh, self.__fbvh, rvhi)

        # Initialize arrays for the complementary field coefficients
        Ivv = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        Ihh = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        Ihv = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        Ivh = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        CIvv = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        CIhh = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        CIhv = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        CIvh = np.zeros((self.iterm,) + self.er.shape, dtype=complex)
        
        # Compute the field coefficients for each term
        for n in range(self.iterm):
            fn = n+1

            # Compute the field coefficients for each polarization
            Ivv[n, ...] = self.__field_sum(vv_terms, fvv, fn, qq1, qq2, qq3, qq4)
            Ihh[n, ...] = self.__field_sum(hh_terms, fhh, fn, qq1, qq2, qq3, qq4)
            Ihv[n, ...] = self.__field_sum(hv_terms, fhv, fn, qq1, qq2, qq3, qq4)
            Ivh[n, ...] = self.__field_sum(vh_terms, fvh, fn, qq1, qq2, qq3, qq4)

            # Compute the conjugate field coefficients
            CIvv[n, ...] = np.conj(Ivv[n, ...])
            CIhh[n, ...] = np.conj(Ihh[n, ...])
            CIhv[n, ...] = np.conj(Ihv[n, ...])
            CIvh[n, ...] = np.conj(Ivh[n, ...])

        return Ivv, Ihh, Ihv, Ivh, CIvv, CIhh, CIhv, CIvh


    def __reflection_coefficients_transition(self, rvi, rhi, rvl, rhl):
        """
        Calculates transition reflection coefficients.

        These coefficients blend the Fresnel reflection coefficients for the
        incident direction and the specular direction using a transition function.
        The transition function depends on the surface roughness and viewing
        geometry, effectively determining how much the scattering behaves like
        specular reflection versus diffuse scattering.

        Parameters
        ----------
        rvi, rhi : complex
            Fresnel reflection coefficients for the incident wave direction
            (co-polarizations V and H).
        rvl, rhl : complex
            Fresnel reflection coefficients for the specular direction
            (co-polarizations V and H).

        Utilizes
        ---------
        self.er, self.si2, self.cs, self.iterm, self.ks, self.spectra_1.

        Returns
        -------
        tuple of complex
            Transition reflection coefficients: rvtran, rhtran, rvhtran, rhvtran.
        """

        sqrt_er = np.sqrt(self.er)
        rv0 = (sqrt_er - 1.0) / (sqrt_er + 1.0)
        rh0 = -rv0  # symmetric relation

        sqrt_term = np.sqrt(self.er - self.si2)
        Ftv = 8.0 * rv0**2 * self.si2 * (self.cs + sqrt_term) / (self.cs * sqrt_term)
        Fth = -8.0 * rh0**2 * self.si2 * (self.cs + sqrt_term) / (self.cs * sqrt_term)

        st0v = 1.0 / np.abs(1.0 + 8.0 * rv0 / (self.cs * Ftv))**2
        st0h = -1.0 / np.abs(1.0 + 8.0 * rh0 / (self.cs * Fth))**2

        sum1 = 0.0
        sum2 = 0.0
        sum3 = 0.0
        temp1 = 1.0

        # Calculate the transition reflection coefficients
        # using the series expansion
        kscs = self.ks * self.cs

        for n in range(self.iterm):
            fn = n+1
            temp1 = temp1 * (1. / fn)
            sum1 += temp1 * kscs**(2. * fn) * self.spectra_1[n]
            sum2 += temp1 * kscs**(2. * fn) * np.abs(Ftv + (2.0**(fn + 2.0) * rv0) / (self.cs * np.exp(kscs**2)))**2 * self.spectra_1[n]
            sum3 += temp1 * kscs**(2. * fn) * np.abs(Fth + (2.0**(fn + 2.0) * rh0) / (self.cs * np.exp(-kscs**2)))**2 * self.spectra_1[n]

        # Calculate the transition reflection coefficients
        stv = np.abs(Ftv)**2 * sum1 / sum2
        sth = np.abs(Fth)**2 * sum1 / sum3
        tfv = 1.0 - stv / st0v
        tfh = 1.0 - sth / st0h
        
        # Avoid division by zero
        tfv = np.where(np.abs(tfv) < 0.0, 0.0, tfv)
        tfh = np.where(np.abs(tfh) < 0.0, 0.0, tfh)

        rvtran = rvi + (rvl - rvi) * tfv
        rhtran = rhi + (rhl - rhi) * tfh
        rvhtran = (rvtran - rhtran) / 2.0
        rhvtran = (rhtran - rvtran) / 2.0

        return rvtran, rhtran, rvhtran, rhvtran


    def __kirchhoff_field_coefficients(self, rh, rv):
        """
        Calculates the Kirchhoff (or Physical Optics) field coefficients.

        These coefficients provide an initial estimate of the scattered fields
        based on the assumption that the surface is locally flat. They are
        derived from the transition reflection coefficients and geometric factors
        related to surface slopes.

        Parameters
        ----------
        rh, rv : complex
            Transition reflection coefficients for horizontal (H) and
            vertical (V) polarizations.

        Utilizes
        ---------
        self.sis, self.csfs, self.si, self.css, self.cs, self.sfs, self.cs2, self.si2.

        Returns
        -------
        tuple of complex
            Kirchhoff field coefficients: fhh, fvv, fhv, fvh.
        """
        # zxx = -(self.sis * self.csfs - self.si) / (self.css + self.cs)
        # zyy = -(self.sis * self.sfs) / (self.css + self.cs)
        
        zxx = -((self.sis * self.csfs) - (self.si * self.csfi)) / (self.css + self.cs)
        zyy = -((self.sis * self.sfs) - (self.si * self.sfi)) / (self.css + self.cs)

        d2 = np.hypot(zxx * self.cs - self.si, zyy)

        # Precomputed terms
        term = self.cs + self.si * zxx

        # Field coefficients
        hsnv = -(self.cs * self.csfs + self.si * (zxx * self.csfs + zyy * self.sfs))
        vsnh = self.css * self.csfs - zxx * self.sis
        hsnh = -self.sfs
        vsnv = zyy * self.cs * self.sis + self.css * (zyy * self.csfs * self.si - term * self.sfs)

        
        # Complex terms simplified
        hsnt = ((-(self.cs2 + self.si2) * self.sfs * (self.si - self.cs * zxx) +
                self.csfs * term * zyy +
                self.si * self.sfs * zyy ** 2) / d2)
        
        hsnd = (-term * (-self.csfs * self.si + self.cs * self.csfs * zxx + self.cs * self.sfs * zyy)) / d2
        
        vsnt = (((self.cs2 + self.si2) * (self.cs * zxx - self.si) * (self.csfs * self.css - self.sis * zxx) +
                self.css * self.sfs * term * zyy -
                (self.csfs * self.css * self.si + self.cs * self.sis) * zyy ** 2) / d2)
        
        vsnd = -term * (self.si * self.sis * zyy - self.css * (self.si * self.sfs - self.cs * self.sfs * zxx + self.cs * self.csfs * zyy)) / d2

        # Field coefficients
        # Shared ratio
        ratio = (rh + rv) * zyy / d2
        fhh = (1. - rh) * hsnv + (1. + rh) * vsnh - (hsnt + vsnd) * ratio
        fvv = -((1. - rv) * hsnv + (1. + rv) * vsnh) + (hsnt + vsnd) * ratio
        fhv = -(1. + rv) * hsnh + (1. - rv) * vsnv + (hsnd - vsnt) * ratio
        fvh = -(1. + rh) * hsnh + (1. - rh) * vsnv + (hsnd - vsnt) * ratio

        return fhh, fvv, fhv, fvh


    def __reflection_coefficients_incident(self):
        """
        Calculates Fresnel reflection coefficients for the incident wave direction.

        These coefficients describe how much of the incident wave is reflected
        at a smooth interface for vertical (V) and horizontal (H) polarizations,
        considering the incident angle `theta_i`.

        Utilizes
        ---------
        self.er, self.ur, self.si, self.cs.

        Returns
        -------
        tuple of complex
            Reflection coefficients: rvi, rhi, rvhi, rhvi.
            `rvhi` and `rhvi` are derived cross-polarization terms.
        """
        stem = np.sqrt(self.er * self.ur - self.si2)

        rvi = (self.er * self.cs - stem) / (self.er * self.cs + stem)
        rhi = (self.ur * self.cs - stem) / (self.ur * self.cs + stem)
        rvhi = (rvi - rhi) / 2.
        rhvi = (rhi - rvi) / 2.

        return rvi, rhi, rvhi, rhvi


    def __reflection_coefficients_specular(self):
        """
        Calculates Fresnel reflection coefficients for an "effective" specular angle.

        This method first determines an effective specular angle based on the
        incident and scattering geometry. Then, it calculates the Fresnel
        reflection coefficients for this effective angle.

        Utilizes
        ---------
        self.cs, self.css, self.si, self.sis, self.csfs, self.er, self.ur.

        Returns
        -------
        tuple of complex
            Reflection coefficients: rvl, rhl, rvhl, rhvl.
            `rvhl` and `rhvl` are derived cross-polarization terms.
        """
        csl = np.sqrt(1.0 + self.cs * self.css - self.si * self.sis * self.csfs) / np.sqrt(2.0)
        sil = np.sqrt(1.0 - csl**2)
        steml = np.sqrt(self.er * self.ur - sil**2)

        rvl = (self.er * csl - steml) / (self.er * csl + steml)
        rhl = (self.ur * csl - steml) / (self.ur * csl + steml)
        rvhl = (rvl - rhl) / 2.0
        rhvl = (rhl - rvl) / 2.0

        return rvl, rhl, rvhl, rhvl


    def __calculate_z_values(self, u, v, qslp):
        """
        Calculates intermediate slope-related terms (zx, zy, zxp, zyp).

        These terms represent components of surface slopes in the x and y
        directions, transformed into the spectral domain. They are used in
        the calculation of Fa and Fb scattering amplitude components.
        A check is included to prevent division by zero.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain, related to spatial frequencies.
        qslp : complex
            A component of the wavenumber, often related to propagation constant.

        Utilizes
        ---------
        self.si, self.sis, self.csfs, self.sfs, self.css, self.cs.

        Returns
        -------
        tuple of complex
            Slope-related terms: zx, zy, zxp, zyp.
        """
        kxu = self.si + u
        ksxu = self.sis * self.csfs + u
        kyv = v
        ksyv = self.sis * self.sfs + v

        d1 = self.css - qslp
        d2 = self.cs + qslp

        # Avoid division by zero
        # Using np.where to handle division by zero
        with np.errstate(divide='ignore', invalid='ignore'):
            zx = np.where(np.abs(d1) < 1e-10, 0., -ksxu / d1)
            zy = np.where(np.abs(d1) < 1e-10, 0., -ksyv / d1)
            zxp = np.where(np.abs(d2) < 1e-10, 0., kxu / d2)
            zyp = np.where(np.abs(d2) < 1e-10, 0., kyv / d2)

        return zx, zy, zxp, zyp


    def __fahh(self, u, v, q, qslp, qfix, rh):
        """
        Calculates the Fa_hh component of the scattering amplitude.

        This function computes a specific term contributing to the horizontally
        polarized scattered field when the incident field is horizontally polarized.
        It involves combinations of surface slope terms (via _c*_func helpers)
        and the horizontal reflection coefficient.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rh : complex
            Horizontal reflection coefficient.

        Utilizes
        ---------
        Internal helper methods _calculate_z_values, _c1_func to _c6_func.

        Returns
        -------
        complex
            The Fa_hh scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        c1 = self.__c1_func(zx, zy, zxp)
        c2 = self.__c2_func(q, u, v, zx, zy, zxp, zyp)
        c3 = self.__c3_func(q, u, v, zx, zy, zxp, zyp)
        c4 = self.__c4_func(zx, zy, zxp, zyp)
        c5 = self.__c5_func(q, u, v, zx, zy, zxp)
        c6 = self.__c6_func(q, u, v, zx, zy, zyp)

        rph = 1.0 + rh
        rmh = 1.0 - rh
        ah = rph / qfix
        bh = rmh / qfix

        return -bh * (-rph * c1 + rmh * c2 + rph * c3) - ah * (rmh * c4 + rph * c5 + rmh * c6)


    def __fahv(self, u, v, q, qslp, qfix, rhv):
        """
        Calculates the Fa_hv component of the scattering amplitude.

        This function computes a specific term contributing to the vertically
        polarized scattered field when the incident field is horizontally polarized
        (cross-polarization). It involves combinations of surface slope terms
        (via _b*_func helpers) and the cross-polarized reflection coefficient.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rhv : complex
            Cross-polarized reflection coefficient (H incident, V scattered).

        Utilizes
        ---------
        Internal helper methods _calculate_z_values, _b1_func to _b6_func.

        Returns
        -------
        complex
            The Fa_hv scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        b1 = self.__b1_func(zx, zy, zxp)
        b2 = self.__b2_func(q, u, v, zx, zy, zxp, zyp)
        b3 = self.__b3_func(q, u, v, zx, zy, zxp, zyp)
        b4 = self.__b4_func(zx, zy, zxp, zyp)
        b5 = self.__b5_func(q, u, v, zx, zy, zxp)
        b6 = self.__b6_func(q, u, v, zx, zy, zyp)

        rp = 1.0 + rhv
        rm = 1.0 - rhv
        a = rp / qfix
        b = rm / qfix

        return b * (rp * b1 - rm * b2 - rp * b3) + a * (rm * b4 + rp * b5 + rm * b6)


    def __favh(self, u, v, q, qslp, qfix, rvh):
        """
        Calculates the Fa_vh component of the scattering amplitude.

        This function computes a specific term contributing to the horizontally
        polarized scattered field when the incident field is vertically polarized
        (cross-polarization). It involves combinations of surface slope terms
        (via _b*_func helpers) and the cross-polarized reflection coefficient.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rvh : complex
            Cross-polarized reflection coefficient (V incident, H scattered).

        Utilizes
        ---------
        Internal helper methods _calculate_z_values, _b1_func to _b6_func.

        Returns
        -------
        complex
            The Fa_vh scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        b1 = self.__b1_func(zx, zy, zxp)
        b2 = self.__b2_func(q, u, v, zx, zy, zxp, zyp)
        b3 = self.__b3_func(q, u, v, zx, zy, zxp, zyp)
        b4 = self.__b4_func(zx, zy, zxp, zyp)
        b5 = self.__b5_func(q, u, v, zx, zy, zxp)
        b6 = self.__b6_func(q, u, v, zx, zy, zyp)

        rp = 1.0 + rvh
        rm = 1.0 - rvh
        a = rp / qfix
        b = rm / qfix

        return b * (rp*b4 + rm*b5 + rp*b6) - a * (-rm*b1 + rp*b2 + rm*b3)


    def __favv(self, u, v, q, qslp, qfix, rv):
        """
        Calculates the Fa_vv component of the scattering amplitude.

        This function computes a specific term contributing to the vertically
        polarized scattered field when the incident field is vertically polarized.
        It involves combinations of surface slope terms (via _c*_func helpers)
        and the vertical reflection coefficient.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rv : complex
            Vertical reflection coefficient.

        Utilizes
        ---------
        Internal helper methods _calculate_z_values, _c1_func to _c6_func.

        Returns
        -------
        complex
            The Fa_vv scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        c1 = self.__c1_func(zx, zy, zxp)
        c2 = self.__c2_func(q, u, v, zx, zy, zxp, zyp)
        c3 = self.__c3_func(q, u, v, zx, zy, zxp, zyp)
        c4 = self.__c4_func(zx, zy, zxp, zyp)
        c5 = self.__c5_func(q, u, v, zx, zy, zxp)
        c6 = self.__c6_func(q, u, v, zx, zy, zyp)

        rpv = 1.0 + rv
        rmv = 1.0 - rv
        av = rpv / qfix
        bv = rmv / qfix

        return bv * (-rpv*c1 + rmv*c2 + rpv*c3) + av * (rmv*c4 + rpv*c5 + rmv*c6)


    def __fbhh(self, u, v, q, qslp, qfix, rh):
        """
        Calculates the Fb_hh component of the scattering amplitude.

        This function computes another specific term contributing to the
        horizontally polarized scattered field when the incident field is
        horizontally polarized. It differs from Fa_hh by incorporating the
        dielectric constant `self.er` in its formulation.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rh : complex
            Horizontal reflection coefficient.

        Utilizes
        ---------
        self.er, and internal helper methods _calculate_z_values, _c1_func to _c6_func.

        Returns
        -------
        complex
            The Fb_hh scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        c1 = self.__c1_func(zx, zy, zxp)
        c2 = self.__c2_func(q, u, v, zx, zy, zxp, zyp)
        c3 = self.__c3_func(q, u, v, zx, zy, zxp, zyp)
        c4 = self.__c4_func(zx, zy, zxp, zyp)
        c5 = self.__c5_func(q, u, v, zx, zy, zxp)
        c6 = self.__c6_func(q, u, v, zx, zy, zyp)

        rph = 1.0 + rh
        rmh = 1.0 - rh
        ah = rph / qfix
        bh = rmh / qfix

        return ah * (-rph * c1 * self.er + rmh * c2 + rph * c3) + \
                    bh * (rmh * c4 + rph * c5 + rmh * c6 / self.er)


    def __fbhv(self, u, v, q, qslp, qfix, rhv):
        """
        Calculates the Fb_hv component of the scattering amplitude.

        This function computes another specific term contributing to the
        vertically polarized scattered field when the incident field is
        horizontally polarized (cross-polarization). It differs from Fa_hv
        by incorporating the dielectric constant `self.er`.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rhv : complex
            Cross-polarized reflection coefficient (H incident, V scattered).

        Utilizes
        ---------
        self.er, and internal helper methods _calculate_z_values, _b1_func to _b6_func.

        Returns
        -------
        complex
            The Fb_hv scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        b1 = self.__b1_func(zx, zy, zxp)
        b2 = self.__b2_func(q, u, v, zx, zy, zxp, zyp)
        b3 = self.__b3_func(q, u, v, zx, zy, zxp, zyp)
        b4 = self.__b4_func(zx, zy, zxp, zyp)
        b5 = self.__b5_func(q, u, v, zx, zy, zxp)
        b6 = self.__b6_func(q, u, v, zx, zy, zyp)

        rp = 1.0 + rhv
        rm = 1.0 - rhv
        a = rp / qfix
        b = rm / qfix

        return a * (-rp * b1 + rm * b2 + rp * b3 / self.er) - \
                    b * (rm * b4 * self.er + rp * b5 + rm * b6)


    def __fbvh(self, u, v, q, qslp, qfix, rvh):
        """
        Calculates the Fb_vh component of the scattering amplitude.

        This function computes another specific term contributing to the
        horizontally polarized scattered field when the incident field is
        vertically polarized (cross-polarization). It differs from Fa_vh
        by incorporating the dielectric constant `self.er`.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rvh : complex
            Cross-polarized reflection coefficient (V incident, H scattered).

        Utilizes
        ---------
        self.er, and internal helper methods _calculate_z_values, _b1_func to _b6_func.

        Returns
        -------
        complex
            The Fb_vh scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        b1 = self.__b1_func(zx, zy, zxp)
        b2 = self.__b2_func(q, u, v, zx, zy, zxp, zyp)
        b3 = self.__b3_func(q, u, v, zx, zy, zxp, zyp)
        b4 = self.__b4_func(zx, zy, zxp, zyp)
        b5 = self.__b5_func(q, u, v, zx, zy, zxp)
        b6 = self.__b6_func(q, u, v, zx, zy, zyp)

        rp = 1.0 + rvh
        rm = 1.0 - rvh
        a = rp / qfix
        b = rm / qfix

        return -a * (rp * b4 + rm * b5 + rp * b6 / self.er) + \
                    b * (-rm * b1 * self.er + rp * b2 + rm * b3)


    def __fbvv(self, u, v, q, qslp, qfix, rv):
        """
        Calculates the Fb_vv component of the scattering amplitude.

        This function computes another specific term contributing to the
        vertically polarized scattered field when the incident field is
        vertically polarized. It differs from Fa_vv by incorporating the
        dielectric constant `self.er`.

        Parameters
        ----------
        u, v : float
            Integration variables in the spectral domain.
        q, qslp, qfix : complex
            Wavenumber-related components.
        rv : complex
            Vertical reflection coefficient.

        Utilizes
        ---------
        self.er, and internal helper methods _calculate_z_values, _c1_func to _c6_func.

        Returns
        -------
        complex
            The Fb_vv scattering amplitude component.
        """

        zx, zy, zxp, zyp = self.__calculate_z_values(u, v, qslp)

        c1 = self.__c1_func(zx, zy, zxp)
        c2 = self.__c2_func(q, u, v, zx, zy, zxp, zyp)
        c3 = self.__c3_func(q, u, v, zx, zy, zxp, zyp)
        c4 = self.__c4_func(zx, zy, zxp, zyp)
        c5 = self.__c5_func(q, u, v, zx, zy, zxp)
        c6 = self.__c6_func(q, u, v, zx, zy, zyp)

        rpv = 1.0 + rv
        rmv = 1.0 - rv
        av = rpv / qfix
        bv = rmv / qfix

        return av * (rpv * c1 - rmv * c2 - rpv * c3 / self.er) - \
                    bv * (rmv * c4 * self.er + rpv * c5 + rmv * c6)


    def __expal(self, q):
        """
        Calculates a specific exponential term used in complementary field coefficients.

        This term is related to the phase shifts due to surface height variations
        and appears frequently in the AIEM equations for complementary fields.

        Parameters
        ----------
        q : complex
            A component of the wavenumber or propagation constant.

        Utilizes
        ---------
        self.ks2, self.css, self.cs

        Returns
        -------
        complex
            The calculated exponential value.
        """
        return np.exp(-self.ks2 * (q ** 2.0 - q * (self.css - self.cs)))


    def __c1_func(self, zx, zy, zxp):
        """
        Calculates the algebraic component c1 for Fa scattering terms.

        This is a low-level helper function implementing a specific algebraic
        combination of surface slope terms and incident/scattered wave parameters.

        Parameters
        ----------
        zx, zy, zxp : complex
            Surface slope-related terms.

        Utilizes
        ---------
        self.csfs, self.sfs

        Returns
        -------
        complex
            The calculated c1 value.
        """
        return -self.csfs * (-1.0 - zx * zxp) + self.sfs * zxp * zy


    def __c2_func(self, q, u, v, zx, zy, zxp, zyp):
        """
        Calculates the algebraic component c2 for Fa scattering terms.

        Parameters
        ----------
        q, u, v, zx, zy, zxp, zyp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.csfs, self.sfs, self.cs, self.si

        Returns
        -------
        complex
            The calculated c2 value.
        """
        return -self.csfs * (-self.cs*q - self.cs*u*zx - q*self.si*zxp - self.si*u*zx*zxp - self.cs*v*zyp - self.si*v*zx*zyp) + \
            self.sfs * (self.cs*u*zy + self.si*u*zxp*zy + q*self.si*zyp - self.cs*u*zyp + self.si*v*zy*zyp)


    def __c3_func(self, q, u, v, zx, zy, zxp, zyp):
        """
        Calculates the algebraic component c3 for Fa scattering terms.

        Parameters
        ----------
        q, u, v, zx, zy, zxp, zyp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.csfs, self.sfs, self.si, self.cs

        Returns
        -------
        complex
            The calculated c3 value.
        """
        return -self.csfs * (self.si*u - q*self.si*zx - self.cs*u*zxp + self.cs*q*zx*zxp) + \
            self.sfs * (-self.si*v + self.cs*v*zxp + q*self.si*zy - self.cs*q*zxp*zy)


    def __c4_func(self, zx, zy, zxp, zyp):
        """
        Calculates the algebraic component c4 for Fa scattering terms.

        Parameters
        ----------
        zx, zy, zxp, zyp : complex
            Surface slope-related terms.

        Utilizes
        ---------
        self.css, self.sfs, self.si, self.cs, self.csfs, self.sis

        Returns
        -------
        complex
            The calculated c4 value.
        """
        return -self.css * self.sfs * (-self.si*zyp + self.cs*zx*zyp) - self.csfs * self.css * (-self.cs - self.si*zxp - self.cs*zy*zyp) + \
            self.sis * (-self.cs*zx - self.si*zx*zxp - self.si*zy*zyp)


    def __c5_func(self, q, u, v, zx, zy, zxp):
        """
        Calculates the algebraic component c5 for Fa scattering terms.

        Parameters
        ----------
        q, u, v, zx, zy, zxp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.css, self.sfs, self.csfs, self.sis

        Returns
        -------
        complex
            The calculated c5 value.
        """
        return -self.css * self.sfs * (-v*zx + v*zxp) - self.csfs * self.css * (q + u*zxp + v*zy) + \
            self.sis * (q*zx + u*zx*zxp + v*zxp*zy)


    def __c6_func(self, q, u, v, zx, zy, zyp):
        """
        Calculates the algebraic component c6 for Fa scattering terms.

        Parameters
        ----------
        q, u, v, zx, zy, zyp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.css, self.sfs, self.csfs, self.sis

        Returns
        -------
        complex
            The calculated c6 value.
        """
        return -self.css * self.sfs * (-u*zyp + q*zx*zyp) - self.csfs * self.css * (v*zyp - q*zy*zyp) + \
            self.sis * (v*zx*zyp - u*zy*zyp)


    def __b1_func(self, zx, zy, zxp):
        """
        Calculates the algebraic component b1 for Fa scattering terms (cross-pol).

        Parameters
        ----------
        zx, zy, zxp : complex
            Surface slope-related terms.

        Utilizes
        ---------
        self.css, self.sfs, self.sis, self.csfs

        Returns
        -------
        complex
            The calculated b1 value.
        """
        return -self.css * self.sfs * (-1.0 - zx * zxp) - self.sis * zy - self.csfs * self.css * zxp * zy


    def __b2_func(self, q, u, v, zx, zy, zxp, zyp):
        """
        Calculates the algebraic component b2 for Fa scattering terms (cross-pol).

        Parameters
        ----------
        q, u, v, zx, zy, zxp, zyp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.css, self.sfs, self.cs, self.si, self.sis, self.csfs

        Returns
        -------
        complex
            The calculated b2 value.
        """
        return -self.css * self.sfs * (-self.cs*q - self.cs*u*zx - q*self.si*zxp - self.si*u*zx*zxp - self.cs*v*zyp - self.si*v*zx*zyp) + \
            self.sis * (-self.cs*q*zy - q*self.si*zxp*zy + q*self.si*zx*zyp - self.cs*u*zx*zyp - self.cs*v*zy*zyp) - \
            self.csfs * self.css * (self.cs*u*zy + self.si*u*zxp*zy + q*self.si*zyp - self.cs*u*zyp + self.si*v*zy*zyp)


    def __b3_func(self, q, u, v, zx, zy, zxp,  zyp):
        """
        Calculates the algebraic component b3 for Fa scattering terms (cross-pol).

        Parameters
        ----------
        q, u, v, zx, zy, zxp, zyp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.css, self.sfs, self.si, self.cs, self.csfs, self.sis

        Returns
        -------
        complex
            The calculated b3 value.
        """
        return -self.css * self.sfs * (self.si*u - q*self.si*zx - self.cs*u*zxp + self.cs*q*zx*zxp) - \
            self.csfs * self.css * (-self.si*v + self.cs*v*zxp + q*self.si*zy - self.cs*q*zxp*zy) + \
            self.sis * (-self.si*v*zx + self.cs*v*zx*zxp + self.si*u*zy - self.cs*u*zxp*zy)


    def __b4_func(self, zx, zy, zxp, zyp):
        """
        Calculates the algebraic component b4 for Fa scattering terms (cross-pol).

        Parameters
        ----------
        zx, zy, zxp, zyp : complex
            Surface slope-related terms.

        Utilizes
        ---------
        self.csfs, self.si, self.cs, self.sfs

        Returns
        -------
        complex
            The calculated b4 value.
        """
        return -self.csfs * (-self.si*zyp + self.cs*zx*zyp) + self.sfs * (-self.cs - self.si*zxp - self.cs*zy*zyp)


    def __b5_func(self, q, u, v, zx, zy, zxp):
        """
        Calculates the algebraic component b5 for Fa scattering terms (cross-pol).

        Parameters
        ----------
        q, u, v, zx, zy, zxp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.csfs, self.sfs

        Returns
        -------
        complex
            The calculated b5 value.
        """
        return -self.csfs * (-v*zx + v*zxp) + self.sfs * (q + u*zxp + v*zy)


    def __b6_func(self, q, u, v, zx, zy, zyp):
        """
        Calculates the algebraic component b6 for Fa scattering terms (cross-pol).

        Parameters
        ----------
        q, u, v, zx, zy, zyp : complex
            Wavenumber components, integration variables, and slope terms.

        Utilizes
        ---------
        self.csfs, self.sfs

        Returns
        -------
        complex
            The calculated b6 value.
        """
        return -self.csfs * (-u*zyp + q*zx*zyp) + self.sfs * (v*zyp - q*zy*zyp)