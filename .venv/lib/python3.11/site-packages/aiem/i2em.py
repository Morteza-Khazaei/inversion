import math
import numpy as np
from scipy.special import erfc, gamma, kv as besselk, jv as besselj
from scipy.integrate import dblquad, quad

class I2EMBistaticModel:
    def __init__(self, fr, sig, L, thi, ths, phs, er, sp, xx):
        self.fr = fr
        self.sig = sig * 100  # convert to cm
        self.L = L * 100
        self.thi = np.radians(thi)
        self.ths = np.radians(ths)
        self.phs = np.radians(phs)
        self.er = er
        self.sp = sp
        self.xx = xx
        self.mu_r = 1
        self.k = 2 * np.pi * fr / 30  # in cm
        self.prepare_angles()
        self.compute_basic_parameters()

    def prepare_angles(self):
        self.cs = np.cos(self.thi + 0.01)
        self.s = np.sin(self.thi + 0.01)
        self.ss = np.sin(self.ths)
        self.css = np.cos(self.ths)
        self.sf = np.sin(0)
        self.cf = np.cos(0)
        self.sfs = np.sin(self.phs)
        self.cfs = np.cos(self.phs)

    def compute_basic_parameters(self):
        self.ks = self.k * self.sig
        self.kl = self.k * self.L
        self.ks2 = self.ks ** 2
        self.s2 = self.s ** 2
        self.kx = self.k * self.s * self.cf
        self.ky = self.k * self.s * self.sf
        self.kz = self.k * self.cs
        self.ksx = self.k * self.ss * self.cfs
        self.ksy = self.k * self.ss * self.sfs
        self.ksz = self.k * self.css
        self.rt = np.sqrt(self.er - self.s2)
        self.Rvi = (self.er * self.cs - self.rt) / (self.er * self.cs + self.rt)
        self.Rhi = (self.cs - self.rt) / (self.cs + self.rt)

    def compute_wn_rss(self, wvnb, Ts):
        wn = np.zeros(Ts)
        if self.sp == 1:
            for n in range(1, Ts + 1):
                wn[n - 1] = self.L ** 2 / n ** 2 * (1 + (wvnb * self.L / n) ** 2) ** -1.5
            rss = self.sig / self.L
        elif self.sp == 2:
            for n in range(1, Ts + 1):
                wn[n - 1] = self.L ** 2 / (2 * n) * np.exp(-(wvnb * self.L) ** 2 / (4 * n))
            rss = np.sqrt(2) * self.sig / self.L
        elif self.sp == 3:
            for n in range(1, Ts + 1):
                if wvnb == 0:
                    wn[n - 1] = self.L ** 2 / (3 * n - 2)
                else:
                    wn[n - 1] = self.L ** 2 * (wvnb * self.L) ** (-1 + self.xx * n) * \
                        besselk(1 - self.xx * n, wvnb * self.L) / (2 ** (self.xx * n - 1) * gamma(self.xx * n))
            rss = np.sqrt(2 * self.xx) * self.sig / self.L
        elif self.sp == 4:
            for n in range(1, Ts + 1):
                integrand = lambda z: np.exp(-abs(z) ** self.xx) * besselj(0, z * wvnb * self.L / (n ** (1 / self.xx))) * z
                tmp, _ = quad(integrand, 0, 9)
                wn[n - 1] = self.L ** 2 / n ** (2 / self.xx) * tmp
            rss = self.sig / self.L
        else:
            raise ValueError("Invalid correlation type.")
        return wn, rss

    def Rav_integration(self, Zx, Zy, cs, s, er, s2, sigx, sigy):
        A = cs + Zx * s
        B = er * (1 + Zx ** 2 + Zy ** 2)
        CC = s2 - 2 * Zx * s * cs + Zx ** 2 * cs ** 2 + Zy ** 2
        Rv = (er * A - np.sqrt(B - CC)) / (er * A + np.sqrt(B - CC))
        pd = np.exp(-Zx ** 2 / (2 * sigx ** 2) - Zy ** 2 / (2 * sigy ** 2))
        return Rv * pd

    def Rah_integration(self, Zx, Zy, cs, s, er, s2, sigx, sigy):
        A = cs + Zx * s
        B = er * (1 + Zx ** 2 + Zy ** 2)
        CC = s2 - 2 * Zx * s * cs + Zx ** 2 * cs ** 2 + Zy ** 2
        Rh = (A - np.sqrt(B - CC)) / (A + np.sqrt(B - CC))
        pd = np.exp(-Zx ** 2 / (2 * sigx ** 2) - Zy ** 2 / (2 * sigy ** 2))
        return Rh * pd

    def Fppupdn_is_calculations(self, ud, is_, Rvi, Rhi, er, k, kz, ksz, s, cs, ss, css, cf, cfs, sfs):
        q = kz
        qt = k * np.sqrt(er - s ** 2)

        if is_ == 1:
            Gqi = ud * kz
            Gqti = ud * k * np.sqrt(er - s ** 2)
            qi = ud * kz
            ks_term = ksz
        else:
            Gqi = ud * ksz
            Gqti = ud * k * np.sqrt(er - ss ** 2)
            qi = ud * ksz
            ks_term = kz

        c11 = k * cfs * (ks_term - qi)
        c12 = k * cfs * (ks_term - qi)

        c21 = cs * (cfs * (k ** 2 * s * cf * (ss * cfs - s * cf) + Gqi * (k * css - qi)) + k ** 2 * cf * s * ss * sfs ** 2)
        c22 = cs * (cfs * (k ** 2 * s * cf * (ss * cfs - s * cf) + Gqti * (k * css - qi)) + k ** 2 * cf * s * ss * sfs ** 2)

        c31 = k * s * (s * cf * cfs * (k * css - qi) - Gqi * (cfs * (ss * cfs - s * cf) + ss * sfs ** 2))
        c32 = k * s * (s * cf * cfs * (k * css - qi) - Gqti * (cfs * (ss * cfs - s * cf) + ss * sfs ** 2))

        c41 = k * cs * (cfs * css * (k * css - qi) + k * ss * (ss * cfs - s * cf))
        c42 = k * cs * (cfs * css * (k * css - qi) + k * ss * (ss * cfs - s * cf))

        c51 = Gqi * (cfs * css * (qi - k * css) - k * ss * (ss * cfs - s * cf))
        c52 = Gqti * (cfs * css * (qi - k * css) - k * ss * (ss * cfs - s * cf))

        vv = (1 + Rvi) * (-(1 - Rvi) * c11 / q + (1 + Rvi) * c12 / qt) + \
             (1 - Rvi) * ((1 - Rvi) * c21 / q - (1 + Rvi) * c22 / qt) + \
             (1 + Rvi) * ((1 - Rvi) * c31 / q - (1 + Rvi) * c32 / (er * qt)) + \
             (1 - Rvi) * ((1 + Rvi) * c41 / q - er * (1 - Rvi) * c42 / qt) + \
             (1 + Rvi) * ((1 + Rvi) * c51 / q - (1 - Rvi) * c52 / qt)

        hh = (1 + Rhi) * ((1 - Rhi) * c11 / q - er * (1 + Rhi) * c12 / qt) - \
             (1 - Rhi) * ((1 - Rhi) * c21 / q - (1 + Rhi) * c22 / qt) - \
             (1 + Rhi) * ((1 - Rhi) * c31 / q - (1 + Rhi) * c32 / qt) - \
             (1 - Rhi) * ((1 + Rhi) * c41 / q - (1 - Rhi) * c42 / qt) - \
             (1 + Rhi) * ((1 + Rhi) * c51 / q - (1 - Rhi) * c52 / qt)

        return vv, hh

    
    def compute_sigma_0(self):
        error = 1e8
        Ts = 1
        while error > 1e-8:
            Ts += 1
            error = (self.ks2 * (self.cs + self.css) ** 2) ** Ts / math.factorial(Ts)

        wvnb = self.k * np.sqrt((self.ss * self.cfs - self.s * self.cf) ** 2 +
                                (self.ss * self.sfs - self.s * self.sf) ** 2)

        wn, rss = self.compute_wn_rss(wvnb, Ts)

        Rv0 = (np.sqrt(self.er) - 1) / (np.sqrt(self.er) + 1)
        Rh0 = -Rv0
        Ft = 8 * Rv0 ** 2 * self.ss * (self.cs + np.sqrt(self.er - self.s2)) / (self.cs * np.sqrt(self.er - self.s2))

        a1 = b1 = 0
        for n in range(1, Ts + 1):
            a0 = (self.ks * self.cs) ** (2 * n) / math.factorial(n)
            exp_term = np.exp(-(self.ks * self.cs) ** 2)
            term2 = (Ft / 2 + 2 ** (n + 1) * Rv0 / self.cs * exp_term) ** 2
            a1 += a0 * wn[n - 1]
            b1 += a0 * term2 * wn[n - 1]

        St = 0.25 * (abs(Ft) ** 2) * a1 / b1
        St0 = 1 / (abs(1 + 8 * Rv0 / (self.cs * Ft))) ** 2
        Tf = 1 - St / St0

        sigx = 1.1 * self.sig / self.L
        sigy = sigx
        xxx = 3 * sigx
        cs, s, er, s2 = self.cs, self.s, self.er, self.s2

        Rav_integrand = lambda Zx, Zy: self.Rav_integration(Zx, Zy, cs, s, er, s2, sigx, sigy)
        Rah_integrand = lambda Zx, Zy: self.Rah_integration(Zx, Zy, cs, s, er, s2, sigx, sigy)

        Rav, _ = dblquad(Rav_integrand, -xxx, xxx, lambda x: -xxx, lambda x: xxx)
        Rah, _ = dblquad(Rah_integrand, -xxx, xxx, lambda x: -xxx, lambda x: xxx)

        Rav /= (2 * np.pi * sigx * sigy)
        Rah /= (2 * np.pi * sigx * sigy)

        if np.isclose(self.thi, self.ths) and np.isclose(np.degrees(self.phs), 180):
            Rvt = self.Rvi + (Rv0 - self.Rvi) * Tf
            Rht = self.Rhi + (Rh0 - self.Rhi) * Tf
        else:
            Rvt = Rav
            Rht = Rah

        fvv = 2 * Rvt * (self.s * self.ss - (1 + self.cs * self.css) * self.cfs) / (self.cs + self.css)
        fhh = -2 * Rht * (self.s * self.ss - (1 + self.cs * self.css) * self.cfs) / (self.cs + self.css)

        qi = self.k * self.cs
        qs = self.k * self.css
        kz, ksz = self.kz, self.ksz
        sig = self.sig

        Fvvupi, Fhhupi = self.Fppupdn_is_calculations(+1, 1, self.Rvi, self.Rhi, self.er, self.k, kz, ksz,
                                                    self.s, self.cs, self.ss, self.css, self.cf, self.cfs, self.sfs)
        Fvvups, Fhhups = self.Fppupdn_is_calculations(+1, 2, self.Rvi, self.Rhi, self.er, self.k, kz, ksz,
                                                    self.s, self.cs, self.ss, self.css, self.cf, self.cfs, self.sfs)
        Fvvdni, Fhhdni = self.Fppupdn_is_calculations(-1, 1, self.Rvi, self.Rhi, self.er, self.k, kz, ksz,
                                                    self.s, self.cs, self.ss, self.css, self.cf, self.cfs, self.sfs)
        Fvvdns, Fhhdns = self.Fppupdn_is_calculations(-1, 2, self.Rvi, self.Rhi, self.er, self.k, kz, ksz,
                                                    self.s, self.cs, self.ss, self.css, self.cf, self.cfs, self.sfs)

        Ivv = np.zeros(Ts)
        Ihh = np.zeros(Ts)

        for n in range(1, Ts + 1):
            idx = n - 1
            Ivv[idx] = ((kz + ksz) ** n * fvv * np.exp(-sig ** 2 * kz * ksz) +
                        0.25 * (Fvvupi * (ksz - qi) ** (n - 1) * np.exp(-sig ** 2 * (qi ** 2 - qi * (ksz - kz))) +
                                Fvvdni * (ksz + qi) ** (n - 1) * np.exp(-sig ** 2 * (qi ** 2 + qi * (ksz - kz))) +
                                Fvvups * (kz + qs) ** (n - 1) * np.exp(-sig ** 2 * (qs ** 2 - qs * (ksz - kz))) +
                                Fvvdns * (kz - qs) ** (n - 1) * np.exp(-sig ** 2 * (qs ** 2 + qs * (ksz - kz)))))
            Ihh[idx] = ((kz + ksz) ** n * fhh * np.exp(-sig ** 2 * kz * ksz) +
                        0.25 * (Fhhupi * (ksz - qi) ** (n - 1) * np.exp(-sig ** 2 * (qi ** 2 - qi * (ksz - kz))) +
                                Fhhdni * (ksz + qi) ** (n - 1) * np.exp(-sig ** 2 * (qi ** 2 + qi * (ksz - kz))) +
                                Fhhups * (kz + qs) ** (n - 1) * np.exp(-sig ** 2 * (qs ** 2 - qs * (ksz - kz))) +
                                Fhhdns * (kz - qs) ** (n - 1) * np.exp(-sig ** 2 * (qs ** 2 + qs * (ksz - kz)))))

        if np.isclose(self.thi, self.ths) and np.isclose(np.degrees(self.phs), 180):
            ct = 1 / np.tan(self.thi)
            cts = 1 / np.tan(self.ths)
            ctorslp = ct / np.sqrt(2) / rss
            ctsorslp = cts / np.sqrt(2) / rss
            shadf = 0.5 * (np.exp(-ctorslp ** 2) / np.sqrt(np.pi) / ctorslp - erfc(ctorslp))
            shadfs = 0.5 * (np.exp(-ctsorslp ** 2) / np.sqrt(np.pi) / ctsorslp - erfc(ctsorslp))
            ShdwS = 1 / (1 + shadf + shadfs)
        else:
            ShdwS = 1

        sigmavv = sigmahh = 0
        for n in range(1, Ts + 1):
            a0 = wn[n - 1] / math.factorial(n) * sig ** (2 * n)
            sigmavv += abs(Ivv[n - 1]) ** 2 * a0
            sigmahh += abs(Ihh[n - 1]) ** 2 * a0

        factor = ShdwS * self.k ** 2 / 2 * np.exp(-sig ** 2 * (kz ** 2 + ksz ** 2))
        sigmavv *= factor
        sigmahh *= factor

        sigma_0_vv = 10 * np.log10(sigmavv)
        sigma_0_hh = 10 * np.log10(sigmahh)

        return sigma_0_vv, sigma_0_hh
    
    def run(self):
        return self.compute_sigma_0()  # σ₀_vv, σ₀_hh in dB
    



if __name__ == "__main__":
    # Example usage
    model = I2EMBistaticModel(
        fr=1.25,       # Frequency in GHz
        sig=0.011,     # RMS height in meters
        L=0.1,         # Correlation length in meters
        thi=30,        # Incidence angle in degrees
        ths=30,        # Scattering angle in degrees
        phs=180,       # Azimuth angle in degrees
        er=15 - 2j,    # Complex dielectric constant
        sp=1,          # Correlation function type (1: exponential)
        xx=2           # Shape parameter (used only for sp=3 or 4)
    )

    sigma_0_vv, sigma_0_hh = model.run()
    print("σ₀_vv (dB):", sigma_0_vv)
    print("σ₀_hh (dB):", sigma_0_hh)