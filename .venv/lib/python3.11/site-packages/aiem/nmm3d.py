import numpy as np
from scipy.interpolate import RegularGridInterpolator

def NMM3D_LUT_NRCS_40degree_interp(rms0, eps0, ratio0, filepath='NMM3D_LUT_NRCS_40degree.dat'):
    """
    Interpolates the NMM3D lookup table for a 40-degree incidence angle to compute
    VV, HH, and cross-polarized backscatter coefficients in dB scale.

    Parameters
    ----------
    rms0 : float
        Normalized RMS height over wavelength.
    eps0 : float
        Real part of relative permittivity (bottom medium / top medium).
    ratio0 : float
        Correlation length divided by RMS height.
    filepath : str
        Path to the lookup table file.

    Returns
    -------
    vv : float
        VV polarized backscatter [dB]
    hh : float
        HH polarized backscatter [dB]
    x : float
        Cross-polarized backscatter [dB]
    """
    LUT = np.loadtxt(filepath)
    LUT = LUT[:, 1:]  # Remove incidence angle column

    ratio_vals = np.array([4, 7, 10, 15])
    if ratio0 < ratio_vals[0] or ratio0 > ratio_vals[-1]:
        raise ValueError('ratio0 is out of range')

    if ratio0 in ratio_vals:
        vv, hh, x = _rblock_interp(LUT, ratio0, eps0, rms0)
    else:
        rs = ratio_vals[ratio_vals < ratio0].max()
        rb = ratio_vals[ratio_vals > ratio0].min()

        vvs, hhs, xs = _rblock_interp(LUT, rs, eps0, rms0)
        vvb, hhb, xb = _rblock_interp(LUT, rb, eps0, rms0)

        vv = _r_interp(rs, rb, vvs, vvb, ratio0)
        hh = _r_interp(rs, rb, hhs, hhb, ratio0)
        x = _r_interp(rs, rb, xs, xb, ratio0)

    return vv, hh, x


def _rblock_interp(LUT, ratio, eps0, rms0):
    """
    Interpolates within a block of LUT entries for a given ratio using RegularGridInterpolator.

    Returns interpolated VV, HH, and cross-pol values.
    """
    block = LUT[LUT[:, 0] == ratio]
    if block.size == 0:
        raise ValueError(f"No data block found for ratio = {ratio}")

    # Unique values for 2D grid
    eps_unique = np.unique(block[:, 1])
    rms_unique = np.unique(block[:, 3])

    # if not (eps_unique[0] <= eps0 <= eps_unique[-1]):
    #     raise ValueError('Permittivity (eps0) out of range')
    # if not (rms_unique[0] <= rms0 <= rms_unique[-1]):
    #     raise ValueError('RMS height (rms0) out of range')

    # Check input ranges with explicit messages
    if not (eps_unique[0] <= eps0 <= eps_unique[-1]):
        print(
            f"eps0 = {eps0} is out of range. Valid range: [{eps_unique[0]}, {eps_unique[-1]}] "
            f"for ratio = {ratio}"
        )
        eps0 = eps_unique[0] if eps0 < eps_unique[0] else eps_unique[-1]


    if not (rms_unique[0] <= rms0 <= rms_unique[-1]):
        print(
            f"rms0 = {rms0} is out of range. Valid range: [{rms_unique[0]}, {rms_unique[-1]}] "
            f"for ratio = {ratio}"
        )
        rms0 = rms_unique[0] if rms0 < rms_unique[0] else rms_unique[-1]


    # Prepare 2D grids: shape must be (len(rms), len(eps)) for interpolation
    grid_shape = (len(rms_unique), len(eps_unique))
    vv_grid = np.full(grid_shape, np.nan)
    hh_grid = np.full(grid_shape, np.nan)
    x_grid = np.full(grid_shape, np.nan)

    for row in block:
        eps_val = row[1]
        rms_val = row[3]
        i = np.where(rms_unique == rms_val)[0][0]
        j = np.where(eps_unique == eps_val)[0][0]
        vv_grid[i, j] = row[4]
        hh_grid[i, j] = row[5]
        x_grid[i, j] = row[6]

    # Interpolators expect inputs in order: (rms, eps)
    vv_interp = RegularGridInterpolator((rms_unique, eps_unique), vv_grid, bounds_error=True)
    hh_interp = RegularGridInterpolator((rms_unique, eps_unique), hh_grid, bounds_error=True)
    x_interp = RegularGridInterpolator((rms_unique, eps_unique), x_grid, bounds_error=True)

    point = np.array([[rms0, eps0]])  # 2D point for interpolation

    vv = float(vv_interp(point))
    hh = float(hh_interp(point))
    x = float(x_interp(point))

    return vv, hh, x


def _r_interp(rs, rb, vs, vb, r0):
    """
    Linear interpolation over the ratio dimension.
    Handles infinities gracefully.
    """
    if np.isfinite(vs) and np.isfinite(vb):
        return np.interp(r0, [rs, rb], [vs, vb])
    else:
        return -np.inf


if __name__ == '__main__':
    # Example usage:
    # Define your input values
    rms0 = 0.1       # normalized RMS height (σ / λ)
    eps0 = 5.0       # relative permittivity (ε2 / ε1)
    ratio0 = 4       # correlation length / RMS height (l / σ)

    # Call the function
    vv, hh, xpol = NMM3D_LUT_NRCS_40degree_interp(rms0, eps0, ratio0, filepath='data/NMM3D/NMM3D_LUT_NRCS_40degree.dat')

    # Print the results
    print(f"VV Backscatter (dB): {vv:.2f}")
    print(f"HH Backscatter (dB): {hh:.2f}")
    print(f"Cross-Polarized Backscatter (dB): {xpol:.2f}")