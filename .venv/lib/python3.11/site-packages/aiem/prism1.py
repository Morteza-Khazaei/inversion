import numpy as np

class PRISM1:
    """
    PRISM-1 Forward Model: Computes radar backscatter coefficients (σ⁰) for VV, HH, and HV polarizations.
    
    Reference: Microwave Radar and Radiometric Remote Sensing, Section 10-5
    """

    def __init__(self, fGHz):
        self.freq = fGHz
        self.k = 2 * np.pi * self.freq / 0.3  # wavenumber in free space [rad/m]
        # c0 = 299792458  # m/s
        # frq_Hz = fGHz * 1e9  # Hz
        # wavelength = c0 / frq_Hz  # meters
        # self.k = 2 * np.pi / wavelength  # wavenumber in free space [rad/m]


    @staticmethod
    def fresnel_reflectivity_normal(eps):
        """Fresnel reflectivity at normal incidence."""
        sqrt_eps = np.sqrt(eps)
        gamma0 = np.abs((1 - sqrt_eps) / (1 + sqrt_eps))**2
        return gamma0

    @staticmethod
    def reflection_coefficients(theta, eps1, eps2):
        """Fresnel reflection coefficients for vertical and horizontal polarization."""
        n1 = np.sqrt(eps1)
        n2 = np.sqrt(eps2)
        sin_theta = np.sin(theta)
        term = (n1 * sin_theta / n2)**2
        costh2 = np.sqrt(1 - term + 0j)  # ensure stability for complex sqrt

        rho_v = -(n2 * np.cos(theta) - n1 * costh2) / (n2 * np.cos(theta) + n1 * costh2)
        rho_h = (n1 * np.cos(theta) - n2 * costh2) / (n1 * np.cos(theta) + n2 * costh2)

        return rho_v, rho_h

    def fresnel_reflectivity(self, eps, theta):
        """Fresnel reflectivities for VV and HH polarization."""
        rho_v, rho_h = self.reflection_coefficients(theta, 1, eps)
        return np.abs(rho_v)**2, np.abs(rho_h)**2

    def forward_model(self, eps, theta_deg, s):
        """
        Run PRISM1 forward model.

        Parameters
        ----------
        eps : complex
            Complex dielectric constant of the surface.
        theta_deg : float
            Incidence angle in degrees.
        s : float
            RMS surface height in meters.

        Returns
        -------
        tuple
            sigma_0_vv, sigma_0_hh, sigma_0_hv in dB
        """
        theta = np.radians(theta_deg)
        ks = self.k * s
        # print(f'ks: {ks}')

        gamma0 = self.fresnel_reflectivity_normal(eps)
        gammav, gammah = self.fresnel_reflectivity(eps, theta)

        p = (1 - ((2 * theta / np.pi)**(1 / (3 * gamma0))) * np.exp(-ks))**2
        q = 0.23 * np.sqrt(gamma0) * (1 - np.exp(-ks))
        g = 0.70 * (1 - np.exp(-0.65 * ks**1.8))

        sigvv = g * (np.cos(theta))**3 / np.sqrt(p) * (gammav + gammah)

        sigma_0_vv = 10 * np.log10(sigvv)
        sigma_0_hh = 10 * np.log10(sigvv * p)
        sigma_0_hv = 10 * np.log10(sigvv * q)

        return sigma_0_vv, sigma_0_hh, sigma_0_hv
