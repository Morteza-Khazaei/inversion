import matplotlib.pyplot as plt
import numpy as np

# Added: plotly for 3D visualization
import plotly.graph_objects as go

# Added: skimage.draw for direct rasterization of shapes
from skimage.draw import ellipse as skimage_ellipse, disk as skimage_disk

# Fixing random state for reproducibility (can be set outside for broader effect)
# np.random.seed(19680801) # You can set this globally or pass a generator

def generate_grayscale_shapes_image(
    image_size: int = 256,
    num_shapes: int = 20,
    shape_types: list = ['ellipse', 'circle'],
    shape_value_min: int = 30,  # New: Minimum intensity for shapes
    shape_value_max: int = 220  # New: Maximum intensity for shapes
) -> np.ndarray:
    """
    Generates a grayscale image with random shapes having specified intensity values.
    Pixels not part of any shape are 0 (black). Overlapping shapes will take
    the value of the shape drawn last.

    Args:
        image_size (int): The width and height of the output image in pixels.
        num_shapes (int): The number of shapes to draw.
        shape_types (list): A list of shape types to choose from (e.g., ['ellipse', 'circle']).
                            Currently supports 'ellipse' and 'circle'.
        shape_value_min (int): Minimum intensity value (0-255) for a shape.
        shape_value_max (int): Maximum intensity value (0-255) for a shape.

    Returns:
        numpy.ndarray: A 2D NumPy array (height, width) representing the grayscale image,
                       with pixel values in the range [0, 255] (uint8).
    """
    if not shape_types:
        raise ValueError("shape_types list cannot be empty.")
    if not (0 <= shape_value_min <= 255 and \
            0 <= shape_value_max <= 255 and \
            shape_value_min <= shape_value_max):
        raise ValueError("Shape intensity values must be between 0 and 255, and min <= max.")

    # Initialize a black image (all zeros)
    image = np.zeros((image_size, image_size), dtype=np.uint8)

    for _ in range(num_shapes):
        chosen_shape_type = np.random.choice(shape_types)
        
        # Determine a random intensity for this shape from the specified range
        current_shape_value = np.random.randint(shape_value_min, shape_value_max + 1)

        # Shape parameters (positions and dimensions are in pixel coordinates)
        center_r = np.random.randint(0, image_size)  # row center
        center_c = np.random.randint(0, image_size)  # column center
        
        # Define min/max radii for shapes relative to image size
        # Ensure radii are at least 1 pixel.
        min_radius_px = max(1, int(image_size / 30))
        max_radius_px = max(min_radius_px + 1, int(image_size / 5)) # Adjusted for more visible shapes

        if chosen_shape_type == 'ellipse':
            # For skimage.draw.ellipse, these are radii
            r_radius = np.random.randint(min_radius_px, max_radius_px)
            c_radius = np.random.randint(min_radius_px, max_radius_px)
            # skimage.draw.ellipse takes orientation in radians
            orientation_rad = np.random.rand() * np.pi  # 0 to pi covers all unique orientations
            
            rr, cc = skimage_ellipse(center_r, center_c, r_radius, c_radius,
                                     shape=image.shape, rotation=orientation_rad)
            image[rr, cc] = current_shape_value

        elif chosen_shape_type == 'circle':
            # For skimage.draw.disk, radius is used
            radius = np.random.randint(min_radius_px, max_radius_px)
            rr, cc = skimage_disk((center_r, center_c), radius, shape=image.shape)
            image[rr, cc] = current_shape_value
        
        # Add other shape types here if needed (e.g., using skimage.draw.polygon)

    return image


# --- Helper functions for 3D shape generation ---

def _generate_sphere_vertices_faces(center_x, center_y, center_z, radius, resolution=20):
    """Generates vertices and triangular faces for a sphere."""
    phi_range = np.linspace(0, 2 * np.pi, resolution)
    theta_range = np.linspace(0, np.pi, resolution)
    phi, theta = np.meshgrid(phi_range, theta_range)

    x_v = center_x + radius * np.sin(theta) * np.cos(phi)
    y_v = center_y + radius * np.sin(theta) * np.sin(phi)
    z_v = center_z + radius * np.cos(theta)

    flat_x = x_v.ravel()
    flat_y = y_v.ravel()
    flat_z = z_v.ravel()

    i_list, j_list, k_list = [], [], []
    for r in range(resolution - 1):
        for c in range(resolution - 1):
            p1 = r * resolution + c
            p2 = r * resolution + (c + 1)
            p3 = (r + 1) * resolution + (c + 1)
            p4 = (r + 1) * resolution + c
            
            i_list.extend([p1, p2])
            j_list.extend([p2, p3])
            k_list.extend([p4, p4])
            
    return flat_x, flat_y, flat_z, i_list, j_list, k_list

def _generate_ellipsoid_vertices_faces(center_x, center_y, center_z, radius_x, radius_y, radius_z, resolution=20):
    """Generates vertices and triangular faces for an ellipsoid."""
    phi_range = np.linspace(0, 2 * np.pi, resolution)
    theta_range = np.linspace(0, np.pi, resolution)
    phi, theta = np.meshgrid(phi_range, theta_range)

    x_v = center_x + radius_x * np.sin(theta) * np.cos(phi)
    y_v = center_y + radius_y * np.sin(theta) * np.sin(phi)
    z_v = center_z + radius_z * np.cos(theta)
    
    flat_x = x_v.ravel()
    flat_y = y_v.ravel()
    flat_z = z_v.ravel()
    
    i_list, j_list, k_list = [], [], []
    for r in range(resolution - 1):
        for c in range(resolution - 1):
            p1 = r * resolution + c
            p2 = r * resolution + (c + 1)
            p3 = (r + 1) * resolution + (c + 1)
            p4 = (r + 1) * resolution + c
            
            i_list.extend([p1, p2]) # Triangle 1: p1, p2, p4
            j_list.extend([p2, p3]) # Triangle 2: p2, p3, p4
            k_list.extend([p4, p4])
            
    return flat_x, flat_y, flat_z, i_list, j_list, k_list

def _generate_cube_vertices_faces(center_x, center_y, center_z, size_x, size_y, size_z):
    """Generates vertices and triangular faces for a cube."""
    dx, dy, dz = size_x / 2, size_y / 2, size_z / 2
    
    # Define 8 vertices of the cube
    x_coords = [center_x - dx, center_x + dx, center_x + dx, center_x - dx, center_x - dx, center_x + dx, center_x + dx, center_x - dx]
    y_coords = [center_y - dy, center_y - dy, center_y + dy, center_y + dy, center_y - dy, center_y - dy, center_y + dy, center_y + dy]
    z_coords = [center_z - dz, center_z - dz, center_z - dz, center_z - dz, center_z + dz, center_z + dz, center_z + dz, center_z + dz]

    # Define indices for 12 triangles (2 per face)
    i_list = [7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2]
    j_list = [3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 2, 3]
    k_list = [0, 7, 2, 3, 0, 7, 2, 7, 5, 5, 7, 6]

    return np.array(x_coords), np.array(y_coords), np.array(z_coords), i_list, j_list, k_list


def generate_3d_shapes_plotly(
    volume_extents: tuple = (10.0, 10.0, 10.0),
    num_shapes: int = 10,
    shape_types: list = ['sphere', 'ellipsoid', 'cube'],
    shape_value_min: float = 0.0,
    shape_value_max: float = 1.0,
    sphere_radius_range: tuple = (0.5, 1.5),
    ellipsoid_radii_range: tuple = (0.3, 1.2), # Min/max for each semi-axis
    cube_size_range: tuple = (0.5, 1.5),       # Min/max for each side
    mesh_resolution: int = 10 
) -> go.Figure:
    """
    Generates a 3D Plotly figure with random shapes.

    Args:
        volume_extents (tuple): Dimensions (size_x, size_y, size_z) of the bounding volume.
        num_shapes (int): The number of 3D shapes to generate.
        shape_types (list): List of shape types to choose from.
        shape_value_min (float): Minimum value for shape intensity/color.
        shape_value_max (float): Maximum value for shape intensity/color.
        sphere_radius_range (tuple): (min, max) for sphere radii.
        ellipsoid_radii_range (tuple): (min, max) for ellipsoid semi-axes.
        cube_size_range (tuple): (min, max) for cube side lengths.
        mesh_resolution (int): Resolution for sphere/ellipsoid mesh generation.

    Returns:
        plotly.graph_objects.Figure: A Plotly figure object containing the 3D shapes.
    """
    if not shape_types:
        raise ValueError("shape_types list cannot be empty.")

    size_x, size_y, size_z = volume_extents
    traces = []

    for i in range(num_shapes):
        chosen_shape_type = np.random.choice(shape_types)
        
        center_x = np.random.uniform(-size_x / 2, size_x / 2)
        center_y = np.random.uniform(-size_y / 2, size_y / 2)
        center_z = np.random.uniform(-size_z / 2, size_z / 2)
        shape_value = np.random.uniform(shape_value_min, shape_value_max)
        
        mesh_x, mesh_y, mesh_z, mesh_i, mesh_j, mesh_k = None, None, None, None, None, None
        name = f"{chosen_shape_type.capitalize()} {i+1}"

        if chosen_shape_type == 'sphere':
            radius = np.random.uniform(sphere_radius_range[0], sphere_radius_range[1])
            mesh_x, mesh_y, mesh_z, mesh_i, mesh_j, mesh_k = _generate_sphere_vertices_faces(
                center_x, center_y, center_z, radius, resolution=mesh_resolution)
        elif chosen_shape_type == 'ellipsoid':
            rx = np.random.uniform(ellipsoid_radii_range[0], ellipsoid_radii_range[1])
            ry = np.random.uniform(ellipsoid_radii_range[0], ellipsoid_radii_range[1])
            rz = np.random.uniform(ellipsoid_radii_range[0], ellipsoid_radii_range[1])
            mesh_x, mesh_y, mesh_z, mesh_i, mesh_j, mesh_k = _generate_ellipsoid_vertices_faces(
                center_x, center_y, center_z, rx, ry, rz, resolution=mesh_resolution)
        elif chosen_shape_type == 'cube':
            sx = np.random.uniform(cube_size_range[0], cube_size_range[1])
            sy = np.random.uniform(cube_size_range[0], cube_size_range[1])
            sz = np.random.uniform(cube_size_range[0], cube_size_range[1])
            mesh_x, mesh_y, mesh_z, mesh_i, mesh_j, mesh_k = _generate_cube_vertices_faces(
                center_x, center_y, center_z, sx, sy, sz)
        
        if mesh_x is not None:
            trace = go.Mesh3d(
                x=mesh_x, y=mesh_y, z=mesh_z,
                i=mesh_i, j=mesh_j, k=mesh_k,
                intensity=np.full(len(mesh_x), shape_value), 
                colorscale='Viridis', 
                opacity=0.6, name=name,
                cmin=shape_value_min, cmax=shape_value_max, # Ensure consistent color mapping
                showscale=(i == 0) # Show color scale only for the first object
            )
            traces.append(trace)

    fig = go.Figure(data=traces)
    fig.update_layout(
        scene=dict(
            xaxis_title='X Axis', yaxis_title='Y Axis', zaxis_title='Z Axis',
            xaxis=dict(range=[-size_x/2 -1, size_x/2 +1], autorange=False, backgroundcolor="rgb(230, 230,230)"),
            yaxis=dict(range=[-size_y/2 -1, size_y/2 +1], autorange=False, backgroundcolor="rgb(230, 230,230)"),
            zaxis=dict(range=[-size_z/2 -1, size_z/2 +1], autorange=False, backgroundcolor="rgb(230, 230,230)"),
            aspectmode='cube',
            camera_eye=dict(x=1.5, y=1.5, z=1.5) # Adjust camera view
        ),
        title_text='3D Random Shapes', title_x=0.5,
        margin=dict(l=10, r=10, b=10, t=50)
    )
    return fig


if __name__ == '__main__':
    # Example Usage:
    # For reproducibility during testing
    np.random.seed(42)

    print("Generating image (256x256, 25 shapes, ellipses and circles, values 50-200)...")
    img_256 = generate_grayscale_shapes_image(
        image_size=256,
        num_shapes=25,
        shape_types=['ellipse', 'circle'],
        shape_value_min=50,
        shape_value_max=200
    )
    print(f"Generated image shape: {img_256.shape}, dtype: {img_256.dtype}, min: {img_256.min()}, max: {img_256.max()}")

    # Display the image (optional)
    plt.figure("Generated Image (256x256)")
    plt.imshow(img_256, cmap='gray', vmin=0, vmax=255)
    plt.title("256x256 Grayscale Shapes (Values 50-200)")
    plt.axis('off')
    plt.show()

    print("\nGenerating image (128x128, 10 shapes, only circles, values 100-150)...")
    img_128_circles = generate_grayscale_shapes_image(
        image_size=128,
        num_shapes=10,
        shape_types=['circle'],
        shape_value_min=100,
        shape_value_max=150
    )
    print(f"Generated image shape: {img_128_circles.shape}, dtype: {img_128_circles.dtype}, min: {img_128_circles.min()}, max: {img_128_circles.max()}")

    plt.figure("Generated Image (128x128 Circles)")
    plt.imshow(img_128_circles, cmap='gray', vmin=0, vmax=255)
    plt.title("128x128 Grayscale Circles (Values 100-150)")
    plt.axis('off')
    plt.show()


    plt.title("128x128 Grayscale Circles (Values 100-150)")
    plt.axis('off')
    plt.show()

    # Example Usage for the new 3D function:
    # For reproducibility
    np.random.seed(101) 

    print("\nGenerating 3D Plotly figure with random shapes...")
    fig_3d = generate_3d_shapes_plotly(
        volume_extents=(20, 20, 15),
        num_shapes=12,
        shape_types=['sphere', 'ellipsoid', 'cube'],
        shape_value_min=0,
        shape_value_max=10,
        sphere_radius_range=(1.0, 2.5),
        ellipsoid_radii_range=(0.8, 2.0),
        cube_size_range=(1.0, 2.2),
        mesh_resolution=12 # Lower resolution for faster example generation
    )
    print("3D Figure generated. If in an interactive environment (like Jupyter),")
    print("you can display it with: fig_3d.show()")
    # To show the figure (uncomment if you want it to pop up automatically):
    # fig_3d.show()