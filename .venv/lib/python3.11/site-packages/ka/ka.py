import numpy as np

class KirchhoffApproximation(object):
    """
    Kirchhoff Approximation (KA) Model for Electromagnetic Scattering
    
    Based on the corrected derivations from the AIEM paper, implementing
    all polarization vector equations and field coefficients.
    """
    
    def __init__(self, k, theta_i, theta_s, phi_i, phi_s, Rv, Rh):
        """
        Initialize KA model with scattering geometry and reflection coefficients.
        
        Parameters:
        -----------
        k : float
            Wavenumber
        theta_i : float
            Incident elevation angle (radians)
        theta_s : float  
            Scattered elevation angle (radians)
        phi_i : float
            Incident azimuth angle (radians)
        phi_s : float
            Scattered azimuth angle (radians)
        Rv : complex
            Vertical polarization Fresnel reflection coefficient
        Rh : complex
            Horizontal polarization Fresnel reflection coefficient
        """
        self.k = k
        self.theta_i = theta_i
        self.theta_s = theta_s
        self.phi_i = phi_i
        self.phi_s = phi_s
        self.Rv = Rv
        self.Rh = Rh
        
        # Precompute trigonometric functions
        self.sin_ti = np.sin(theta_i)
        self.cos_ti = np.cos(theta_i)
        self.sin_ts = np.sin(theta_s)
        self.cos_ts = np.cos(theta_s)
        self.sin_pi = np.sin(phi_i)
        self.cos_pi = np.cos(phi_i)
        self.sin_ps = np.sin(phi_s)
        self.cos_ps = np.cos(phi_s)
        
        # Compute surface slopes using stationary phase approximation
        self.zx, self.zy = self._compute_surface_slopes()
        
        # Compute normalization factors
        self.D1 = np.sqrt(1 + self.zx**2 + self.zy**2)
        self.D2 = np.sqrt(self.zy**2 + (self.sin_ti - self.zx * self.cos_ti)**2)
        
    def _compute_surface_slopes(self):
        """
        Compute surface slopes using stationary phase approximation (Eq. 18).
        
        Wave vectors (corrected convention):
        k_i: (sin θ_i cos φ_i, sin θ_i sin φ_i, -cos θ_i)  [downward]
        k_s: (sin θ_s cos φ_s, sin θ_s sin φ_s, +cos θ_s)  [upward]
        """
        # Incident wave vector components (downward propagation)
        kx_i = self.k * self.sin_ti * self.cos_pi
        ky_i = self.k * self.sin_ti * self.sin_pi
        kz_i = -self.k * self.cos_ti  # Negative for downward propagation
        
        # Scattered wave vector components (upward propagation)
        kx_s = self.k * self.sin_ts * self.cos_ps
        ky_s = self.k * self.sin_ts * self.sin_ps
        kz_s = self.k * self.cos_ts   # Positive for upward propagation
        
        # Stationary phase relations (Eq. 18)
        denominator = kz_s - kz_i  # This is kz_s + |kz_i|
        if np.isclose(denominator, 0.0):
            raise ValueError("Invalid scattering geometry: kz_s - kz_i ≈ 0")
            
        zx = -(kx_s - kx_i) / denominator
        zy = -(ky_s - ky_i) / denominator
        
        return zx, zy
    
    def _compute_cross_products(self):
        """Compute all required dot products from our corrected derivations."""
        
        # Shorthand for readability
        st_i, ct_i = self.sin_ti, self.cos_ti
        st_i2 = st_i**2
        ct_i2 = ct_i**2
        st_s, ct_s = self.sin_ts, self.cos_ts
        sp_i, cp_i = self.sin_pi, self.cos_pi
        sp_s, cp_s = self.sin_ps, self.cos_ps
        zx, zy = self.zx, self.zy
        
        # Angle differences
        sin_dphi = np.sin(self.phi_i - self.phi_s)
        sin_dphi_si = np.sin(self.phi_s - self.phi_i)
        cos_dphi_si = np.cos(self.phi_s - self.phi_i)  # For scattered-incident
        cos_dphi_is = np.cos(self.phi_i - self.phi_s)  # For incident-scattered
        
        # ========================================
        # Cross products with surface normal
        # ========================================
        
        # v_s · (n × v_i) - Equation we verified
        vs_cross_nv = (ct_i * ct_s * sin_dphi 
                      - zx * st_i * ct_s * sp_s
                      - zx * ct_i * sp_i * st_s  
                      + zy * st_i * ct_s * cp_s
                      + zy * ct_i * cp_i * st_s) / self.D1
        
        # v_s · (n × h_i) - Rederived eq
        # \hat{v}_s \cdot (\hat{n} \times \hat{h}) = \frac{1}{D_1}[\cos \theta_s \cos(\phi_s + \phi) - z_x \cos \phi \sin \theta_s - z_y \sin \phi \sin \theta_s]
        # v_s · (n × h)
        vs_cross_nh = (ct_s * np.cos(self.phi_s + self.phi_i) 
                       - zx * cp_i * st_s
                       - zy * sp_i * st_s) / self.D1
        
        # h_s · (n × v_i) - Equation we verified
        # \hat{h}_s \cdot (\hat{n} \times \hat{v}) = -\frac{1}{D_1}[\cos \theta \cos(\phi_s - \phi) + z_x \sin \theta \cos \phi_s + z_y \sin \theta \sin \phi_s]
        hs_cross_nv = -(ct_i * cos_dphi_si 
                       + zx * st_i * cp_s
                       + zy * st_i * sp_s) / self.D1
        
        # h_s · (n × h_i) - Equation we verified
        hs_cross_nh = -np.sin(self.phi_s + self.phi_i) / self.D1
        
        # ========================================
        # Dot products with local vectors t and d
        # ========================================
        
        # v_i · t - Our mathematically derived version
        # \hat{v} \cdot \hat{t} = \frac{1}{D_2}\left[z_x \cos^2 \theta (\sin \phi - \cos \phi) - \cos \theta \sin \theta \sin \phi - z_y \sin^2 \theta\right]
        v_dot_t = (zx * ct_i2 * (sp_i - cp_i) - (ct_i * st_i * sp_i) - zy * st_i2) / self.D2
        
        # h_i · d - Verified equation 
        # Perfect Match! ✓
        # \hat{h} \cdot \hat{d} = \frac{1}{D_2}\left[\cos \theta \sin \phi(\sin \theta - z_x \cos \theta) + z_y \cos \phi\right]
        h_dot_d = (ct_i * sp_i * (st_i - zx * ct_i) + zy * cp_i) / self.D2
        
        # v_s · t - Corrected from our derivation 
        # \hat{v}_s \cdot \hat{t} = \frac{1}{D_2}\left[\cos \theta_s \sin \phi_s \sin \theta 
        # - z_y \sin \theta_s \sin \theta 
        # + z_x \cos \theta \cos \theta_s (\cos \phi_s - \sin \phi_s)\right]
        vs_dot_t = (ct_s * sp_s * st_i 
                    - zy * st_s * st_i
                    + zx * ct_i * ct_s * (cp_s - sp_s)) / self.D2

        # v_s · d - Corrected from our derivation  
        # \hat{v}_s \cdot \hat{d} = \frac{1}{D_2}\left[(\cos \theta \cos \theta_s \cos \phi_s 
        # - \sin \theta \sin \theta_s)(\sin \theta - z_x \cos \theta) - z_y \cos \theta_s \sin \phi_s\right]
        vs_dot_d = ((ct_i * ct_s * cp_s - st_i * st_s) * (st_i - zx * ct_i) 
                    - zy * ct_s * sp_s) / self.D2

        # h_s · d - Verified equation
        # \hat{h}_s \cdot \hat{d} = -\frac{1}{D_2}\left[\cos \theta \sin \phi_s(\sin \theta - z_x \cos \theta) + z_y \cos \phi_s\right]
        hs_dot_d = -(ct_i * sp_s * (st_i - zx * ct_i) + zy * cp_s) / self.D2
        
        # h_s · t - Our corrected derivation (zx not zy)
        # \hat{h}_s \cdot \hat{t} = \frac{1}{D_2}\left[\cos \phi_s \sin \theta - z_x \cos \theta(\sin \phi_s + \cos \phi_s)\right]
        hs_dot_t = (cp_s * st_i - zx * ct_i * (sp_s + cp_s)) / self.D2
        
        # ========================================
        # Other required dot products
        # ========================================
        
        # n · k_i - Verified with corrected wave vector
        # \hat{n} \cdot \hat{k}_i = -\frac{1}{D_1}\left[\cos \theta + z_x \sin \theta \cos \phi + z_y \sin \theta \sin \phi\right]
        n_dot_ki = -(ct_i + zx * st_i * cp_i + zy * st_i * sp_i) / self.D1
        
        # n · d - Verified equation
        # \hat{n} \cdot \hat{d} = -\frac{1}{D_1 D_2}\left[(\sin \theta - z_x \cos \theta)^2 + z_y^2\right]
        n_dot_d = -((st_i - zx * ct_i)**2 + zy**2) / (self.D1 * self.D2)
        
        # h_s · k_i - Verified equation
        # \hat{h}_s \cdot \hat{k}_i = \sin \theta \sin(\phi_s - \phi)
        hs_dot_ki = st_i * sin_dphi_si
        
        # v_s · k_i - Verified with corrected wave vectors
        # \hat{v}_s \cdot \hat{k}_i = -[\cos \theta \sin \theta_s + \sin \theta \cos \theta_s \cos(\phi_s - \phi)]
        vs_dot_ki = -(ct_i * st_s + st_i * ct_s * cos_dphi_si)
        
        return {
            'vs_cross_nv': vs_cross_nv,
            'vs_cross_nh': vs_cross_nh, 
            'hs_cross_nv': hs_cross_nv,
            'hs_cross_nh': hs_cross_nh,
            'v_dot_t': v_dot_t,
            'h_dot_d': h_dot_d,
            'vs_dot_t': vs_dot_t,
            'vs_dot_d': vs_dot_d,
            'hs_dot_d': hs_dot_d,
            'hs_dot_t': hs_dot_t,
            'n_dot_ki': n_dot_ki,
            'n_dot_d': n_dot_d,
            'hs_dot_ki': hs_dot_ki,
            'vs_dot_ki': vs_dot_ki
        }
    
    def field_coefficients(self):
        """
        Compute the four Kirchhoff field coefficients.
        
        Returns:
        --------
        tuple : (fhh, fvv, fvh, fhv)
            Complex field coefficients for the four polarization combinations
        """
        # Get all dot products
        dots = self._compute_cross_products()
        
        # Extract reflection coefficients
        Rv, Rh = self.Rv, self.Rh
        D1 = self.D1
        
        # ========================================
        # Field Coefficients (Equations 19-22)
        # ========================================
        
        # f_vv: Vertical incident → Vertical scattered
        fvv = (-((1 - Rv) * dots['hs_cross_nv'] + (1 + Rv) * dots['vs_cross_nh']) * D1
               - (Rh + Rv) * dots['v_dot_t'] * 
               ((dots['hs_dot_d'] * dots['n_dot_ki'] - dots['n_dot_d'] * dots['hs_dot_ki'] 
                 - dots['vs_dot_t'] * dots['n_dot_ki']) * D1))
        
        # f_vh: Vertical incident → Horizontal scattered  
        fvh = (((1 - Rh) * dots['vs_cross_nv'] - (1 + Rh) * dots['hs_cross_nh']) * D1
               - (Rh + Rv) * dots['h_dot_d'] * 
               ((dots['hs_dot_t'] * dots['n_dot_ki'] - dots['n_dot_d'] * dots['vs_dot_ki']
                 + dots['vs_dot_d'] * dots['n_dot_ki']) * D1))
        
        # f_hv: Horizontal incident → Vertical scattered
        fhv = (((1 - Rv) * dots['vs_cross_nv'] - (1 + Rv) * dots['hs_cross_nh']) * D1
               - (Rh + Rv) * dots['v_dot_t'] * 
               ((dots['hs_dot_t'] * dots['n_dot_ki'] - dots['n_dot_d'] * dots['vs_dot_ki']
                 + dots['vs_dot_d'] * dots['n_dot_ki']) * D1))
        
        # f_hh: Horizontal incident → Horizontal scattered
        fhh = (((1 + Rh) * dots['vs_cross_nh'] + (1 - Rh) * dots['hs_cross_nv']) * D1
               - (Rh + Rv) * dots['h_dot_d'] * 
               ((dots['hs_dot_d'] * dots['n_dot_ki'] - dots['n_dot_d'] * dots['hs_dot_ki']
                 - dots['vs_dot_t'] * dots['n_dot_ki']) * D1))
        
        return fhh, fvv, fvh, fhv
    
    def get_surface_slopes(self):
        """Return the computed surface slopes."""
        return self.zx, self.zy
    
    def get_normalization_factors(self):
        """Return the normalization factors D1 and D2."""
        return self.D1, self.D2
    
    def verify_orthogonality(self):
        """
        Verify that polarization vectors satisfy orthogonality constraints.
        Returns dict with all dot products that should be zero.
        """
        st_i, ct_i = self.sin_ti, self.cos_ti
        st_s, ct_s = self.sin_ts, self.cos_ts
        sp_i, cp_i = self.sin_pi, self.cos_pi
        sp_s, cp_s = self.sin_ps, self.cos_ps
        
        # Polarization vectors (corrected)
        h_i = np.array([-sp_i, cp_i, 0])
        v_i = np.array([ct_i * cp_i, ct_i * sp_i, st_i])
        h_s = np.array([sp_s, -cp_s, 0])
        v_s = np.array([-ct_s * cp_s, -ct_s * sp_s, st_s])
        
        # Wave vectors (corrected)
        k_i = np.array([st_i * cp_i, st_i * sp_i, -ct_i])
        k_s = np.array([st_s * cp_s, st_s * sp_s, ct_s])
        
        return {
            'h_i_dot_k_i': np.dot(h_i, k_i),
            'v_i_dot_k_i': np.dot(v_i, k_i), 
            'h_i_dot_v_i': np.dot(h_i, v_i),
            'h_s_dot_k_s': np.dot(h_s, k_s),
            'v_s_dot_k_s': np.dot(v_s, k_s),
            'h_s_dot_v_s': np.dot(h_s, v_s),
            '|h_i|': np.linalg.norm(h_i),
            '|v_i|': np.linalg.norm(v_i),
            '|h_s|': np.linalg.norm(h_s),
            '|v_s|': np.linalg.norm(v_s)
        }


# ========================================
# Test and Comparison
# ========================================

if __name__ == "__main__":
    # Test parameters
    k = 1.132
    theta_i = np.radians(30)
    theta_s = np.radians(30) 
    phi_i = np.radians(0)
    phi_s = np.radians(180)
    Rv, Rh = 0.6 + 0.1j, 0.4 + 0.05j  # Complex reflection coefficients
    
    # Create KA model
    ka = KirchhoffApproximation(k, theta_i, theta_s, phi_i, phi_s, Rv, Rh)
    
    # Compute field coefficients
    fhh, fvv, fvh, fhv = ka.field_coefficients()
    
    # Display results
    print("Kirchhoff Approximation Field Coefficients:")
    print(f"f_hh = {fhh:.6f}")
    print(f"f_vv = {fvv:.6f}")
    print(f"f_vh = {fvh:.6f}")
    print(f"f_hv = {fhv:.6f}")
    
    # Verify orthogonality
    ortho = ka.verify_orthogonality()
    print("\nOrthogonality Verification (should be ~0):")
    for key, value in ortho.items():
        if 'dot' in key:
            print(f"{key}: {value:.8f}")
        else:
            print(f"{key}: {value:.8f}")
    
    # Display surface slopes and normalization factors
    zx, zy = ka.get_surface_slopes()
    D1, D2 = ka.get_normalization_factors()
    print(f"\nSurface slopes: zx = {zx:.6f}, zy = {zy:.6f}")
    print(f"Normalization: D1 = {D1:.6f}, D2 = {D2:.6f}")