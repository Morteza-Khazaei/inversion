import numpy as np

class VectorizedKirchhoffApproximation:
    """
    Vectorized Kirchhoff Approximation Model using NumPy vector operations.
    
    This implementation eliminates sign convention errors by using NumPy's
    built-in dot and cross product functions directly on vector arrays.
    """
    
    def __init__(self, theta_i, theta_s, phi_i, phi_s, Rv, Rh):
        """
        Initialize vectorized KA model.
        
        Parameters:
        -----------
        theta_i : float
            Incident elevation angle (radians)
        theta_s : float  
            Scattered elevation angle (radians)
        phi_i : float
            Incident azimuth angle (radians)
        phi_s : float
            Scattered azimuth angle (radians)
        Rv : complex
            Vertical polarization Fresnel reflection coefficient
        Rh : complex
            Horizontal polarization Fresnel reflection coefficient
        """
        self.theta_i = theta_i
        self.theta_s = theta_s
        self.phi_i = phi_i
        self.phi_s = phi_s
        self.Rv = Rv
        self.Rh = Rh
        
        # Precompute all vectors using exact definitions
        self._setup_vectors()
        
        # Compute surface slopes and normalization factors
        self.zx, self.zy = self._compute_surface_slopes()
        self.D1 = np.sqrt(1 + self.zx**2 + self.zy**2)
        self.D2 = np.sqrt(self.zy**2 + (np.sin(theta_i) - self.zx * np.cos(theta_i))**2)
        
        # Update surface-dependent vectors
        self._setup_surface_vectors()
        
    def _setup_vectors(self):
        """Define all polarization and wave vectors using exact definitions."""
        
        # Wave vectors (following the paper's convention)
        # Incident: downward propagation (negative z-component)
        self.k_i = np.array([
            np.sin(self.theta_i) * np.cos(self.phi_i),
            np.sin(self.theta_i) * np.sin(self.phi_i),
            -np.cos(self.theta_i)  # Negative for downward propagation
        ])
        
        # Scattered: upward propagation (positive z-component)
        self.k_s = np.array([
            np.sin(self.theta_s) * np.cos(self.phi_s),
            np.sin(self.theta_s) * np.sin(self.phi_s),
            np.cos(self.theta_s)   # Positive for upward propagation
        ])
        
        # Incident polarization vectors (from paper definitions)
        self.h_i = np.array([
            -np.sin(self.phi_i),
            np.cos(self.phi_i),
            0
        ])
        
        # Use the paper's definition for v_i (with the negative sign)
        self.v_i = np.array([
            np.cos(self.theta_i) * np.cos(self.phi_i),
            np.cos(self.theta_i) * np.sin(self.phi_i),
            np.sin(self.theta_i)
        ])
        
        # Scattered polarization vectors (from paper definitions)
        self.h_s = -np.array([
            -np.sin(self.phi_s),
            np.cos(self.phi_s),
            0
        ])
        
        self.v_s = -np.array([
            np.cos(self.theta_s) * np.cos(self.phi_s),
            np.cos(self.theta_s) * np.sin(self.phi_s),
            -np.sin(self.theta_s)
        ])
        
    def _compute_surface_slopes(self):
        """Compute surface slopes using stationary phase approximation."""
        # Wave vector components
        kx_i = self.k_i[0]
        ky_i = self.k_i[1]
        kz_i = self.k_i[2]
        
        kx_s = self.k_s[0]
        ky_s = self.k_s[1]
        kz_s = self.k_s[2]
        
        # Stationary phase relations (Eq. 18)
        denominator = kz_s - kz_i
        if np.isclose(denominator, 0.0):
            raise ValueError("Invalid scattering geometry: kz_s - kz_i ≈ 0")
            
        zx = -(kx_s - kx_i) / denominator
        zy = -(ky_s - ky_i) / denominator
        
        return zx, zy
        
    def _setup_surface_vectors(self):
        """Define surface normal and local surface vectors."""
        
        # Surface normal vector
        self.n = np.array([-self.zx, -self.zy, 1]) / self.D1

        # Compute t = (k_i × n) / |k_i × n|
        k_cross_n = np.cross(self.k_i, self.n)
        k_cross_n_magnitude = np.linalg.norm(k_cross_n)
        self.t = k_cross_n / k_cross_n_magnitude
        
        # Compute d = k_i × t
        self.d = np.cross(self.k_i, self.t)
        
    def compute_all_dot_products(self):
        """
        Compute all required dot and cross products using NumPy operations.
        This eliminates any manual calculation errors and sign convention issues.
        """
        results = {}
        
        # Cross products with surface normal
        results['vs_dot_n_cross_vi'] = np.dot(self.v_s, np.cross(self.n, self.v_i))
        results['vs_dot_n_cross_hi'] = np.dot(self.v_s, np.cross(self.n, self.h_i))
        results['hs_dot_n_cross_vi'] = np.dot(self.h_s, np.cross(self.n, self.v_i))
        results['hs_dot_n_cross_hi'] = np.dot(self.h_s, np.cross(self.n, self.h_i))
        
        # Dot products with local surface vectors
        results['vi_dot_t'] = np.dot(self.v_i, self.t)
        results['hi_dot_d'] = np.dot(self.h_i, self.d)
        results['vs_dot_t'] = np.dot(self.v_s, self.t)
        results['vs_dot_d'] = np.dot(self.v_s, self.d)
        results['hs_dot_t'] = np.dot(self.h_s, self.t)
        results['hs_dot_d'] = np.dot(self.h_s, self.d)
        
        # Other required dot products
        results['n_dot_ki'] = np.dot(self.n, self.k_i)
        results['n_dot_d'] = np.dot(self.n, self.d)
        results['hs_dot_ki'] = np.dot(self.h_s, self.k_i)
        results['vs_dot_ki'] = np.dot(self.v_s, self.k_i)
        
        return results
    
    def field_coefficients(self):
        """
        Compute Kirchhoff field coefficients using vectorized operations.
        
        Returns:
        --------
        tuple : (fhh, fvv, fvh, fhv)
            Complex field coefficients
        """
        # Get all dot products
        dots = self.compute_all_dot_products()
        
        # Extract reflection coefficients
        Rv, Rh = self.Rv, self.Rh
        D1 = self.D1

        # co-pol common term
        co_pol_bracket = (dots['hs_dot_d'] * dots['n_dot_ki'] 
                          - dots['n_dot_d'] * dots['hs_dot_ki'] 
                          - dots['vs_dot_t'] * dots['n_dot_ki'])
        
        # x-pol common term
        xpol_bracket = (dots['hs_dot_t'] * dots['n_dot_ki'] 
                        - dots['n_dot_d'] * dots['vs_dot_ki'] 
                        + dots['vs_dot_d'] * dots['n_dot_ki'])
        
        # f_vv: Vertical incident → Vertical scattered
        fvv = -((1 - Rv) * dots['hs_dot_n_cross_vi'] + (1 + Rv) * dots['vs_dot_n_cross_hi']) * D1 \
            - (Rh + Rv) * dots['vi_dot_t'] * co_pol_bracket * D1
        
        # f_vh: Vertical incident → Horizontal scattered
        fvh = ((1 - Rh) * dots['vs_dot_n_cross_vi'] - (1 + Rh) * dots['hs_dot_n_cross_hi']) * D1 \
            - (Rh + Rv) * dots['hi_dot_d'] * xpol_bracket * D1
        
        # f_hv: Horizontal incident → Vertical scattered
        fhv = -((1 - Rv) * dots['vs_dot_n_cross_vi'] - (1 + Rv) * dots['hs_dot_n_cross_hi']) * D1 \
            -(Rh + Rv) * dots['vi_dot_t'] * xpol_bracket * D1
        
        # f_hh: Horizontal incident → Horizontal scattered
        fhh = ((1 + Rh) * dots['vs_dot_n_cross_hi'] + (1 - Rh) * dots['hs_dot_n_cross_vi']) * D1 \
            - (Rh + Rv) * dots['hi_dot_d'] * co_pol_bracket * D1
        
        return fhh, fvv, fvh, fhv
    
    def verify_orthogonality(self):
        """Verify electromagnetic orthogonality constraints using NumPy."""
        return {
            'hi_dot_ki': np.dot(self.h_i, self.k_i),
            'vi_dot_ki': np.dot(self.v_i, self.k_i),
            'hi_dot_vi': np.dot(self.h_i, self.v_i),
            'hs_dot_ks': np.dot(self.h_s, self.k_s),
            'vs_dot_ks': np.dot(self.v_s, self.k_s),
            'hs_dot_vs': np.dot(self.h_s, self.v_s),
            'norm_hi': np.linalg.norm(self.h_i),
            'norm_vi': np.linalg.norm(self.v_i),
            'norm_hs': np.linalg.norm(self.h_s),
            'norm_vs': np.linalg.norm(self.v_s)
        }
    
    def compare_with_analytical(self):
        """
        Compare vectorized results with our analytical derivations.
        This helps verify which analytical expressions were correct.
        """
        dots = self.compute_all_dot_products()
        
        print("=== VECTORIZED vs ANALYTICAL COMPARISON ===\n")
        
        # Compare key expressions we derived
        print("Cross products with surface normal:")
        print(f"v_s · (n × v_i) = {dots['vs_dot_n_cross_vi']:.6f}")
        print(f"v_s · (n × h_i) = {dots['vs_dot_n_cross_hi']:.6f}")  
        print(f"h_s · (n × v_i) = {dots['hs_dot_n_cross_vi']:.6f}")
        print(f"h_s · (n × h_i) = {dots['hs_dot_n_cross_hi']:.6f}")
        
        print("\nDot products with local vectors:")
        print(f"v_i · t = {dots['vi_dot_t']:.6f}")
        print(f"h_i · d = {dots['hi_dot_d']:.6f}")
        print(f"v_s · t = {dots['vs_dot_t']:.6f}")
        print(f"v_s · d = {dots['vs_dot_d']:.6f}")
        print(f"h_s · t = {dots['hs_dot_t']:.6f}")
        print(f"h_s · d = {dots['hs_dot_d']:.6f}")
        
        print("\nOther dot products:")
        print(f"n · k_i = {dots['n_dot_ki']:.6f}")
        print(f"n · d = {dots['n_dot_d']:.6f}")
        print(f"h_s · k_i = {dots['hs_dot_ki']:.6f}")
        print(f"v_s · k_i = {dots['vs_dot_ki']:.6f}")
        
        return dots
    
    def get_all_vectors(self):
        """Return all computed vectors for inspection."""
        return {
            'k_i': self.k_i,
            'k_s': self.k_s,
            'h_i': self.h_i,
            'v_i': self.v_i,
            'h_s': self.h_s,
            'v_s': self.v_s,
            'n': self.n,
            't': self.t,
            'd': self.d,
            'surface_slopes': (self.zx, self.zy),
            'normalization': (self.D1, self.D2)
        }


# ========================================
# Test and Verification
# ========================================

if __name__ == "__main__":
    # Test parameters
    theta_i = np.radians(30)
    theta_s = np.radians(30) 
    phi_i = np.radians(0)
    phi_s = np.radians(180)
    Rv, Rh = 0.6 + 0.1j, 0.4 + 0.05j
    
    # Create vectorized KA model
    vka = VectorizedKirchhoffApproximation(theta_i, theta_s, phi_i, phi_s, Rv, Rh)
    
    # Compute field coefficients
    fhh, fvv, fvh, fhv = vka.field_coefficients()
    
    print("VECTORIZED Kirchhoff Field Coefficients:")
    print(f"f_hh = {fhh:.6f}")
    print(f"f_vv = {fvv:.6f}")
    print(f"f_vh = {fvh:.6f}")
    print(f"f_hv = {fhv:.6f}")
    
    print("\n" + "="*50)
    
    # Verify orthogonality
    ortho = vka.verify_orthogonality()
    print("\nOrthogonality Verification (should be ~0):")
    for key, value in ortho.items():
        if 'dot' in key:
            print(f"{key}: {value:.8f}")
        else:
            print(f"{key}: {value:.8f}")
    
    print("\n" + "="*50)
    
    # Compare with analytical expressions
    dots = vka.compare_with_analytical()
    
    print("\n" + "="*50)
    
    # Display surface slopes and normalization factors
    vectors = vka.get_all_vectors()
    zx, zy = vectors['surface_slopes']
    D1, D2 = vectors['normalization']
    print(f"\nSurface slopes: zx = {zx:.6f}, zy = {zy:.6f}")
    print(f"Normalization: D1 = {D1:.6f}, D2 = {D2:.6f}")
    
    print("\nVector magnitudes:")
    for name, vec in vectors.items():
        if isinstance(vec, np.ndarray) and vec.ndim == 1:
            print(f"|{name}| = {np.linalg.norm(vec):.6f}")
    
    print("\n" + "="*50)